import PrimeNumberTheoremAnd.MediumPNT
import StrongPNT.ZetaZeroFree

set_option lang.lemmaCmd true
set_option maxHeartbeats 400000

--Put in a namespace to avoid collisions with MediumPNT
namespace Strong
open Set Function Filter Complex Real

open ArithmeticFunction (vonMangoldt)


local notation (name := mellintransform2) "ùìú" => mellin

local notation "Œõ" => vonMangoldt

local notation "Œ∂" => riemannZeta

local notation "Œ∂'" => deriv Œ∂

local notation "I" => Complex.I

local notation "œà" => ChebyshevPsi


open ComplexConjugate
open MeasureTheory

/-- Our preferred left vertical line. -/
@[inline] noncomputable def sigma1Of (A T : ‚Ñù) : ‚Ñù := 1 - A / Real.log T

def LogDerivZetaHasBound (A C : ‚Ñù) : Prop := ‚àÄ (œÉ : ‚Ñù) (t : ‚Ñù) (_ : 3 < |t|)
    (_ : œÉ ‚àà Ici (1 - A / Real.log |t|)), ‚ÄñŒ∂' (œÉ + t * I) / Œ∂ (œÉ + t * I)‚Äñ ‚â§
    C * Real.log |t| ^ 9


theorem log_pos (T : ‚Ñù) (T_gt : 3 < T) : (Real.log T > 1) := by
    have elt3 : Real.exp 1 < 3 := by
      linarith[Real.exp_one_lt_d9]
    have logTgt1 : Real.log T > 1 := by
      refine (lt_log_iff_exp_lt ?_).mpr ?_
      ¬∑ linarith
      ¬∑ linarith
    exact logTgt1

/-%%
\begin{lemma}[I2Bound]\label{I2Bound}\lean{I2Bound}\leanok
We have that
$$
\left|I_{2}(\nu, \epsilon, X, T)\right| \ll \frac{X}{\epsilon T}
.
$$
\end{lemma}
%%-/
lemma I2Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
--    (mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {A C‚ÇÇ : ‚Ñù} (has_bound: LogDerivZetaHasBound A C‚ÇÇ) (C‚ÇÇpos : 0 < C‚ÇÇ) (A_in : A ‚àà Ioc 0 (1 / 2)) :
    ‚àÉ (C : ‚Ñù) (_ : 0 < C),
    ‚àÄ(X : ‚Ñù) (_ : 3 < X) {Œµ : ‚Ñù} (_ : 0 < Œµ)
    (_ : Œµ < 1) {T : ‚Ñù} (_ : 3 < T),
    let œÉ‚ÇÅ := sigma1Of A T
    ‚ÄñI‚ÇÇ SmoothingF Œµ T X œÉ‚ÇÅ‚Äñ ‚â§ C * X / (Œµ * T) := by
  have ‚ü®C‚ÇÅ, C‚ÇÅpos, Mbd‚ü© := MellinOfSmooth1b ContDiffSmoothingF suppSmoothingF
  have := (IBound_aux1 3 (by norm_num) 9)
  obtain ‚ü®C‚ÇÉ, ‚ü®C‚ÇÉ_gt, hC‚ÇÉ‚ü©‚ü© := this

  let C' : ‚Ñù := C‚ÇÅ * C‚ÇÇ * C‚ÇÉ * rexp 1
  have : C' > 0 := by positivity
  use ‚Äñ1/(2*œÄ*I)‚Äñ * (2 * C'), by
    refine Right.mul_pos ?_ ?_
    ¬∑ rw[norm_pos_iff]
      simp[pi_ne_zero]
    ¬∑ simp[this]
  intro X X_gt Œµ Œµ_pos Œµ_lt_one T T_gt œÉ‚ÇÅ
--  clear suppSmoothingF mass_one ContDiffSmoothingF
  have Xpos : 0 < X := lt_trans (by simp only [Nat.ofNat_pos]) X_gt
  have Tpos : 0 < T := lt_trans (by norm_num) T_gt
  have log_big : 1 < Real.log T := by exact log_pos T (T_gt)
  unfold I‚ÇÇ
  rw[norm_mul, mul_assoc (c := X), ‚Üê mul_div]
  refine mul_le_mul_of_nonneg_left ?_ (norm_nonneg _)
  have interval_length_nonneg : œÉ‚ÇÅ ‚â§ 1 + (Real.log X)‚Åª¬π := by
    have : œÉ‚ÇÅ = sigma1Of A T := rfl
    rw [this]
    unfold sigma1Of
    rw[sub_le_iff_le_add]
    nth_rw 1 [‚Üê add_zero 1]
    rw[add_assoc]
    apply add_le_add_left
    refine Left.add_nonneg ?_ ?_
    ¬∑ rw[inv_nonneg, log_nonneg_iff Xpos]
      exact le_trans (by norm_num) (le_of_lt X_gt)
    ¬∑ refine div_nonneg ?_ ?_
      exact A_in.1.le
      rw[log_nonneg_iff Tpos]
      exact le_trans (by norm_num) (le_of_lt T_gt)
  have : œÉ‚ÇÅ = sigma1Of A T := rfl
  have œÉ‚ÇÅpos : 0 < œÉ‚ÇÅ := by
    have : œÉ‚ÇÅ = sigma1Of A T := rfl
    rw [this]
    unfold sigma1Of
    rw[sub_pos]
    calc
      A / Real.log T ‚â§ 1 / 2 / Real.log T := by
        refine div_le_div_of_nonneg_right (A_in.2) ?_
        apply le_of_lt
        linarith
        -- refine (lt_log_iff_exp_lt ?_).mpr ?_ <;> (Tpos)
      _ ‚â§ 1 / 2 / 1 := by
        refine div_le_div_of_nonneg_left (by norm_num) (by norm_num) ?_
        apply le_of_lt
        refine (lt_log_iff_exp_lt ?_).mpr ?_ <;> linarith[Real.exp_one_lt_d9]
      _ < 1 := by norm_num
  suffices ‚àÄ œÉ ‚àà Ioc œÉ‚ÇÅ (1 + (Real.log X)‚Åª¬π), ‚ÄñSmoothedChebyshevIntegrand SmoothingF Œµ X (‚ÜëœÉ - ‚ÜëT * I)‚Äñ ‚â§ C' * X / (Œµ * T) by
    calc
      ‚Äñ‚à´ (œÉ : ‚Ñù) in œÉ‚ÇÅ..1 + (Real.log X)‚Åª¬π,
          SmoothedChebyshevIntegrand SmoothingF Œµ X (‚ÜëœÉ - ‚ÜëT * I)‚Äñ ‚â§
          C' * X / (Œµ * T) * |1 + (Real.log X)‚Åª¬π - œÉ‚ÇÅ| := by
        refine intervalIntegral.norm_integral_le_of_norm_le_const ?_
        convert this using 3
        apply uIoc_of_le
        exact interval_length_nonneg
      _ ‚â§ C' * X / (Œµ * T) * 2 := by
        apply mul_le_mul_of_nonneg_left
        rw[abs_of_nonneg (sub_nonneg.mpr interval_length_nonneg)]
        calc
          1 + (Real.log X)‚Åª¬π - œÉ‚ÇÅ ‚â§ 1 + (Real.log X)‚Åª¬π := by linarith
          _ ‚â§ 2 := (one_add_inv_log X_gt.le).le
        positivity
      _ = 2 * C' * X / (Œµ * T) := by ring
  -- Now bound the integrand
  intro œÉ hœÉ
  unfold SmoothedChebyshevIntegrand
  have log_deriv_zeta_bound : ‚ÄñŒ∂' (œÉ - T * I) / Œ∂ (œÉ - T * I)‚Äñ ‚â§ C‚ÇÇ * (C‚ÇÉ * T) := by
    calc
      ‚ÄñŒ∂' (œÉ - (T : ‚Ñù) * I) / Œ∂ (œÉ - (T : ‚Ñù) * I)‚Äñ = ‚ÄñŒ∂' (œÉ + (-T : ‚Ñù) * I) / Œ∂ (œÉ + (-T : ‚Ñù) * I)‚Äñ := by
        have Z : œÉ - (T : ‚Ñù) * I = œÉ + (- T : ‚Ñù) * I := by simp; ring_nf
        simp [Z]
      _ ‚â§ C‚ÇÇ * Real.log |-T| ^ 9 := has_bound œÉ (-T) (by simp; rw [abs_of_pos Tpos]; exact T_gt) (by rw[this] at hœÉ; unfold sigma1Of at hœÉ; simp at hœÉ ‚ä¢; replace hœÉ := hœÉ.1; linarith)
      _ ‚â§ C‚ÇÇ * Real.log T ^ 9 := by simp
      _ ‚â§ C‚ÇÇ * (C‚ÇÉ * T) := by gcongr; exact hC‚ÇÉ T (by linarith)

  -- Then estimate the remaining factors.
  calc
    ‚Äñ-Œ∂' (œÉ - T * I) / Œ∂ (œÉ - T * I) * ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ))
        (œÉ - T * I) * X ^ (œÉ - T * I)‚Äñ =
        ‚Äñ-Œ∂' (œÉ - T * I) / Œ∂ (œÉ - T * I)‚Äñ * ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ))
        (œÉ - T * I)‚Äñ * ‚Äñ(X : ‚ÑÇ) ^ (œÉ - T * I)‚Äñ := by
      repeat rw[norm_mul]
    _ ‚â§ C‚ÇÇ * (C‚ÇÉ * T) * (C‚ÇÅ * (Œµ * ‚ÄñœÉ - T * I‚Äñ ^ 2)‚Åª¬π) * (rexp 1 * X) := by
      apply mul_le_mul‚ÇÉ
      ¬∑ rw[neg_div, norm_neg]
        exact log_deriv_zeta_bound
      ¬∑ refine Mbd œÉ‚ÇÅ œÉ‚ÇÅpos _ ?_ ?_ Œµ Œµ_pos Œµ_lt_one
        ¬∑ simp only [mem_Ioc, sub_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one,
            sub_self, sub_zero, sigma1Of] at hœÉ ‚ä¢
          linarith
        ¬∑ simp only [mem_Ioc, sub_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one,
            sub_self, sub_zero, sigma1Of] at hœÉ ‚ä¢
          linarith[one_add_inv_log X_gt.le]
      ¬∑ rw[cpow_def_of_ne_zero]
        ¬∑ rw[norm_exp,‚Üê ofReal_log, re_ofReal_mul]
          simp only [sub_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self,
            sub_zero, sigma1Of]
          rw[‚Üê le_log_iff_exp_le, Real.log_mul (exp_ne_zero 1), Real.log_exp, ‚Üê le_div_iff‚ÇÄ', add_comm, add_div, div_self, one_div]
          exact hœÉ.2
          ¬∑ refine (Real.log_pos ?_).ne.symm
            linarith
          ¬∑ apply Real.log_pos
            linarith
          ¬∑ linarith
          ¬∑ positivity
          ¬∑ positivity
        ¬∑ exact_mod_cast Xpos.ne.symm
      ¬∑ positivity
      ¬∑ positivity
      ¬∑ positivity
    _ = (C' * X * T) / (Œµ * ‚ÄñœÉ - T * I‚Äñ ^ 2) := by ring
    _ ‚â§ C' * X / (Œµ * T) := by
      have : ‚ÄñœÉ - T * I‚Äñ ^ 2 ‚â• T ^ 2 := by
        calc
          ‚ÄñœÉ - T * I‚Äñ ^ 2 = ‚ÄñœÉ + (-T : ‚Ñù) * I‚Äñ ^ 2 := by
            congr 2
            push_cast
            ring
          _ = normSq (œÉ + (-T : ‚Ñù) * I) := (normSq_eq_norm_sq _).symm
          _ = œÉ^2 + (-T)^2 := by
            rw[Complex.normSq_add_mul_I]
          _ ‚â• T^2 := by
            rw[neg_sq]
            exact le_add_of_nonneg_left (sq_nonneg _)
      calc
        C' * X * T / (Œµ * ‚Äñ‚ÜëœÉ - ‚ÜëT * I‚Äñ ^ 2) ‚â§ C' * X * T / (Œµ * T ^ 2) := by
          rw[div_le_div_iff_of_pos_left, mul_le_mul_left]
          exact this
          exact Œµ_pos
          positivity
          apply mul_pos Œµ_pos
          exact lt_of_lt_of_le (pow_pos Tpos 2) this
          positivity
        _ = C' * X / (Œµ * T) := by
          field_simp
          ring
/-%%
\begin{proof}\uses{MellinOfSmooth1b, LogDerivZetaBndUniform, I2, I8}\leanok
Unfold the definitions and apply the triangle inequality.
$$
\left|I_{2}(\nu, \epsilon, X, T, \sigma_1)\right| =
\left|\frac{1}{2\pi i} \int_{\sigma_1}^{\sigma_0}
\left(\frac{-\zeta'}\zeta(\sigma - T i) \right) \cdot
\mathcal M(\widetilde 1_\epsilon)(\sigma - T i) \cdot
X^{\sigma - T i}
 \ d\sigma
\right|
$$
$$\leq
\frac{1}{2\pi}
\int_{\sigma_1}^{\sigma_0}
C \cdot \log T ^ 9
\frac{C'}{\epsilon|\sigma - T i|^2}
X^{\sigma_0}
 \ d\sigma
 \leq
C'' \cdot \frac{X\log T^9}{\epsilon T^2}
,
$$
where we used Theorems \ref{MellinOfSmooth1b} and \ref{LogDerivZetaBndUniform}, and the fact that
$X^\sigma \le X^{\sigma_0} = X\cdot X^{1/\log X}=e \cdot X$.
Since $T>3$, we have $\log T^9 \leq C''' T$.
\end{proof}
%%-/

/-%%
\begin{lemma}[I8Bound]\label{I8Bound}\lean{I8Bound}\leanok
We have that
$$
\left|I_{8}(\nu, \epsilon, X, T)\right| \ll \frac{X}{\epsilon T}
.
$$
\end{lemma}
%%-/
lemma I8Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {A C‚ÇÇ : ‚Ñù} (has_bound : LogDerivZetaHasBound A C‚ÇÇ) (C‚ÇÇ_pos : 0 < C‚ÇÇ) (A_in : A ‚àà Ioc 0 (1 / 2)) :
--    (mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1) :
    ‚àÉ (C : ‚Ñù) (_ : 0 < C),
    ‚àÄ(X : ‚Ñù) (_ : 3 < X) {Œµ : ‚Ñù} (_: 0 < Œµ)
    (_ : Œµ < 1)
    {T : ‚Ñù} (_ : 3 < T),
    let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
    ‚ÄñI‚Çà SmoothingF Œµ T X œÉ‚ÇÅ‚Äñ ‚â§ C * X / (Œµ * T) := by

  obtain ‚ü®C, hC, i2Bound‚ü© := I2Bound suppSmoothingF ContDiffSmoothingF has_bound C‚ÇÇ_pos A_in
  use C, hC
  intro X hX Œµ hŒµ0 hŒµ1 T hT œÉ‚ÇÅ
  let i2Bound := i2Bound X hX hŒµ0 hŒµ1 hT
  rw[I8I2 hX, norm_neg, norm_conj]
  -- intro m
  change ‚ÄñI‚ÇÇ SmoothingF Œµ T X (sigma1Of A T)‚Äñ ‚â§ C * X / (Œµ * T) at i2Bound
  unfold sigma1Of at i2Bound
  have œÉ‚ÇÅ_eq : œÉ‚ÇÅ = 1 - A / (Real.log T) := rfl
  rw[œÉ‚ÇÅ_eq]
  exact i2Bound

/-%%
\begin{proof}\uses{I8I2, I2Bound}\leanok
  We deduce this from the corresponding bound for $I_2$, using the symmetry between $I_2$ and $I_8$.
\end{proof}
%%-/


/-%%
\begin{lemma}[I3Bound]\label{I3Bound}\lean{I3Bound}\leanok
We have that
$$
\left|I_{3}(\nu, \epsilon, X, T)\right| \ll \frac{X}{\epsilon}\, X^{-\frac{A}{(\log T)^9}}
.
$$
Same with $I_7$.
\end{lemma}
%%-/

theorem I3Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {A CŒ∂ : ‚Ñù} (hCŒ∂ : LogDerivZetaHasBound A CŒ∂) (CŒ∂pos : 0 < CŒ∂) (hA : A ‚àà Ioc 0 (1 / 2)) :
    ‚àÉ (C : ‚Ñù) (_ : 0 < C),
      ‚àÄ (X : ‚Ñù) (_ : 3 < X)
        {Œµ : ‚Ñù} (_ : 0 < Œµ) (_ : Œµ < 1)
        {T : ‚Ñù} (_ : 3 < T),
        --(SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
        --(mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1),
        let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
        ‚ÄñI‚ÇÉ SmoothingF Œµ T X œÉ‚ÇÅ‚Äñ ‚â§ C * X * X ^ (- A / (Real.log T)) / Œµ := by
--  intro SmoothingF suppSmoothingF ContDiffSmoothingF
  obtain ‚ü®CM, CMpos, CMhyp‚ü© := MellinOfSmooth1b ContDiffSmoothingF suppSmoothingF
  obtain ‚ü®Cint, Cintpos, Cinthyp‚ü© := log_pow_over_xsq_integral_bounded 9
  use Cint * CM * CŒ∂
  have : Cint * CM > 0 := mul_pos Cintpos CMpos
  have : Cint * CM * CŒ∂ > 0 := mul_pos this CŒ∂pos
  use this
  intro X Xgt3 Œµ Œµgt0 Œµlt1 T Tgt3 œÉ‚ÇÅ -- SmoothingFnonneg mass_one
  unfold I‚ÇÉ
  unfold SmoothedChebyshevIntegrand

  have elt3 : Real.exp 1 < 3 := by
    linarith[Real.exp_one_lt_d9]

  have log3gt1: 1 < Real.log 3 := by
    apply (Real.lt_log_iff_exp_lt (by norm_num)).mpr
    exact elt3

  have logXgt1 : Real.log X > 1 := by
    refine (lt_log_iff_exp_lt ?_).mpr ?_
    linarith
    linarith

  have logTgt1 : Real.log T > 1 := by
    refine (lt_log_iff_exp_lt ?_).mpr ?_
    linarith
    linarith

  have logX9gt1 : Real.log X ^ 1 > 1 := by
    refine (one_lt_pow_iff_of_nonneg ?_ ?_).mpr logXgt1
    linarith
    linarith

  have logT9gt1 : Real.log T ^ 1 > 1 := by
    refine (one_lt_pow_iff_of_nonneg ?_ ?_).mpr logTgt1
    linarith
    linarith

  have t_bounds : ‚àÄ t ‚àà Ioo (-T) (-3), 3 < |t| ‚àß |t| < T := by
    intro t ht
    obtain ‚ü®h1,h2‚ü© := ht
    have : |t| = -t := by
      refine abs_of_neg ?_
      linarith[h2]
    have abs_tgt3 : 3 < |t| := by
      rw[this]
      linarith[h2]
    have abs_tltX : |t| < T := by
      rw[this]
      linarith[h1]
    exact ‚ü®abs_tgt3, abs_tltX‚ü©

  have logtgt1_bounds : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí Real.log |t| > 1 := by
    intro t ht
    obtain ‚ü®h1,h2‚ü© := ht
    refine logt_gt_one ?_
    exact h1.le

  have logt9gt1_bounds : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí Real.log |t| ^ 9  > 1 := by
    intro t ht
    refine one_lt_pow‚ÇÄ (logtgt1_bounds t ht) ?_
    linarith

  have logtltlogT_bounds : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí Real.log |t| < Real.log T := by
    intro t ht
    obtain ‚ü®h1,h2‚ü© := ht
    have m := log_lt_log (by linarith : 0 < (|t|)) (h2 : |t| < T )
    exact m

  have logt9ltlogT9_bounds : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí Real.log |t| ^ 9 < Real.log T ^ 9 := by
    intro t ht
    obtain h1 := logtltlogT_bounds t ht
    obtain h2 := logtgt1_bounds t ht
    have h3: 0 ‚â§ Real.log |t| := by linarith
    refine (pow_lt_pow_iff_left‚ÇÄ ?_ ?_ ?_).mpr h1
    linarith
    linarith
    linarith

  have Aoverlogt9gtAoverlogT9_bounds : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí
        A / Real.log |t| ^ 9 > A / Real.log T ^ 9 := by
    intro t ht
    have h1 := logt9ltlogT9_bounds t ht
    have h2 :=logt9gt1_bounds t ht
    refine div_lt_div_of_pos_left ?_ ?_ h1
    linarith [hA.1]
    linarith

  have AoverlogT9in0half: A / Real.log T ^ 1 ‚àà Ioo 0 (1/2) := by
    constructor
    ¬∑ refine div_pos ?_ ?_
      refine EReal.coe_pos.mp ?_
      exact EReal.coe_lt_coe hA.1
      linarith
    ¬∑ refine (div_lt_comm‚ÇÄ ?_ ?_).mpr ?_
      linarith
      linarith
      refine (div_lt_iff‚ÇÄ' ?_).mpr ?_
      linarith
      have hA_lt : A ‚â§ 1 / 2 := hA.2
      have hbound : 1 / 2 < (1 / 2) * Real.log T ^ 1 := by
        linarith
      linarith

  have œÉ‚ÇÅlt2 : (œÉ‚ÇÅ : ‚Ñù) < 2 := by
    unfold œÉ‚ÇÅ
    calc 1 - A / Real.log T
      < 1 - 0 := by simp only [sub_zero]; exact sub_lt_self 1 (div_pos hA.1 (lt_trans zero_lt_one logTgt1))
      _ = 1 := by norm_num
      _ < 2 := by norm_num

  have œÉ‚ÇÅlt1 : œÉ‚ÇÅ < 1 := by
    unfold œÉ‚ÇÅ
    calc 1 - A / Real.log T
      < 1 - 0 := by simp only [sub_zero]; exact sub_lt_self 1 (div_pos hA.1 (by linarith [logTgt1]))
      _ = 1 := by norm_num

  have œÉ‚ÇÅpos : 0 < œÉ‚ÇÅ := by
    unfold œÉ‚ÇÅ
    rw [sub_pos]
    calc
      A / Real.log T ‚â§ (1/2) / Real.log T := by
        apply div_le_div_of_nonneg_right hA.2 (by linarith)
      _ ‚â§ (1/2) / 1 := by
        apply div_le_div_of_nonneg_left (by norm_num) (by norm_num) (by linarith)
      _ = 1/2 := by norm_num
      _ < 1 := by norm_num

  have quotient_bound : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2) ‚â§ Real.log |t| ^ 9/ t ^ 2  := by
    intro t ht
    have loght := logt9gt1_bounds t ht
    have logpos : Real.log |t| ^ 9 > 0 := by linarith
    have denom_le : t ^ 2 ‚â§ œÉ‚ÇÅ ^ 2 + t ^ 2 := by linarith [sq_nonneg œÉ‚ÇÅ]
    have denom_pos : 0 < t ^ 2 := by
      have : t ^ 2 = |t| ^ 2 := by
        exact Eq.symm (sq_abs t)
      rw [this]
      have h1 := ht.1
      have abspos : |t| > 0 := by linarith
      exact sq_pos_of_pos abspos
    have denom2_pos : 0 < œÉ‚ÇÅ ^ 2 + t ^ 2 := by linarith [sq_nonneg œÉ‚ÇÅ]
    exact (div_le_div_iff_of_pos_left logpos denom2_pos denom_pos).mpr denom_le

  have boundthing : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí œÉ‚ÇÅ ‚àà Ici (1 - A / Real.log |t|) := by
    intro t ht
    have h1 := Aoverlogt9gtAoverlogT9_bounds t ht
    unfold œÉ‚ÇÅ
    apply mem_Ici.mpr
    ring_nf
    -- We need to show: 1 - A / log T ‚â• 1 - A / log |t|
    -- Equivalently: A / log |t| ‚â• A / log T
    -- Since A > 0 and log T < log |t| (because |t| < T), this follows
    apply sub_le_sub_left
    have : Real.log |t| ‚â§ Real.log T := by
      apply Real.log_le_log (by linarith) (le_of_lt ht.2)
    exact div_le_div_of_nonneg_left (le_of_lt hA.1) (Real.log_pos (by linarith)) this

  have : ‚à´ (t : ‚Ñù) in -T..-3,
          -Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) * ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
            ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) = ‚à´ (t : ‚Ñù) in Ioo (-T : ‚Ñù) (-3 : ‚Ñù),
          -Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) * ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
            ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) := by
    rw [intervalIntegral.integral_of_le (by linarith)]
    exact MeasureTheory.integral_Ioc_eq_integral_Ioo
  rw[this]

  have MellinBound : ‚àÄ (t : ‚Ñù) , ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (œÉ‚ÇÅ + t * I)‚Äñ ‚â§ CM * (Œµ * ‚Äñ(œÉ‚ÇÅ + t * I)‚Äñ ^ 2)‚Åª¬π := by
    intro t
    apply CMhyp œÉ‚ÇÅ
    exact œÉ‚ÇÅpos
    dsimp
    ring_nf
    rfl
    dsimp
    ring_nf
    linarith
    exact Œµgt0
    exact Œµlt1

  have logzetabnd : ‚àÄ t : ‚Ñù, 3 < |t| ‚àß |t| < T ‚Üí ‚ÄñŒ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ ‚â§ CŒ∂ * Real.log (|t| : ‚Ñù) ^ 9 := by
    intro t tbounds
    obtain ‚ü®tgt3, tltT‚ü© := tbounds
    apply hCŒ∂
    ¬∑ exact tgt3
    ¬∑ apply boundthing
      constructor
      ¬∑ exact tgt3
      ¬∑ exact tltT

  have Mellin_bd : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí
  ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (œÉ‚ÇÅ + t * I)‚Äñ ‚â§ CM * (Œµ * ‚ÄñœÉ‚ÇÅ + t * I‚Äñ ^ 2)‚Åª¬π := by
    intro t ht
    apply MellinBound

  have logzeta_bd : ‚àÄ t, 3 < |t| ‚àß |t| < T ‚Üí
    ‚ÄñŒ∂' (œÉ‚ÇÅ + t * I) / Œ∂ (œÉ‚ÇÅ + t * I)‚Äñ ‚â§ CŒ∂ * Real.log |t| ^ 9 := by
    intro t t_bounds
    obtain ‚ü®abs_tgt3,abs_tltX‚ü© := t_bounds
    apply logzetabnd
    constructor
    ¬∑ exact abs_tgt3
    ¬∑ exact abs_tltX
  have : ‚Äñ1 / (2 * ‚ÜëœÄ * I) *
        (I * ‚à´ (t : ‚Ñù) in -X..-3,
          -Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
          ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
          ‚ÜëT ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I))‚Äñ
    =
    (1 / (2 * œÄ)) * ‚Äñ‚à´ (t : ‚Ñù) in -X..-3,
        -Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
        ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
        ‚ÜëT ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ := by
    simp only [norm_mul, norm_eq_abs, abs_neg, abs_one, one_mul, mul_one]
    rw[Complex.norm_I]
    simp only [norm_mul, norm_eq_abs, abs_neg, abs_one, one_mul, mul_one]
    have : ‚Äñ1 / (2 * ‚ÜëœÄ * I)‚Äñ = 1 / (2 * œÄ) := by
      dsimp
      ring_nf
      simp only [norm_mul, norm_eq_abs, abs_neg, abs_one, one_mul, mul_one]
      rw[inv_I]
      have : ‚Äñ-I‚Äñ = ‚Äñ-1 * I‚Äñ := by
        simp
      rw[this]
      have : ‚Äñ-1 * I‚Äñ = ‚Äñ-1‚Äñ * ‚ÄñI‚Äñ := by
        simp
      rw[this, Complex.norm_I]
      ring_nf
      simp
      exact pi_nonneg
    rw[this]

  let f t := (-Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)) *
        ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
        ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)

  let g t := CŒ∂ * CM * Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2) * X ^ œÉ‚ÇÅ

  have norm_X_sigma1: ‚àÄ (t : ‚Ñù), ‚Äñ‚Üë(X : ‚ÑÇ) ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ = X ^ œÉ‚ÇÅ := by
    intro t
    have Xpos : 0 < X := by linarith
    have : ((‚ÜëœÉ‚ÇÅ + ‚Üët * I).re) = œÉ‚ÇÅ := by
      dsimp
      ring_nf
    nth_rw 2[‚Üê this]
    apply Complex.norm_cpow_eq_rpow_re_of_pos Xpos

  have bound_integral : ‚àÄ (t : ‚Ñù), 3  < |t| ‚àß |t| < T ‚Üí ‚Äñf t‚Äñ ‚â§ g t := by
    intro t
    rintro ‚ü®ht_gt3, ht_ltT‚ü©
    have XœÉ_bound : ‚Äñ‚Üë(X : ‚ÑÇ) ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ = X ^ œÉ‚ÇÅ := norm_X_sigma1 t
    have logtgt1 : 1 < Real.log |t| := by
        exact logt_gt_one ht_gt3.le
    have hŒ∂ := logzetabnd t ‚ü®ht_gt3, ht_ltT‚ü©
    have hùìú := MellinBound t
    have : ‚Äñf ‚Üët‚Äñ = ‚Äñ(-Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)) *
            ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
            ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ := by
      rfl
    rw[this]
    have : ‚Äñ(-Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)) *
            ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
            ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ ‚â§ ‚ÄñŒ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ *
            ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ *
            ‚Äñ(‚Üë(X : ‚Ñù) : ‚ÑÇ) ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ := by
      simp [norm_neg]

    have : ‚ÄñŒ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ *
            ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ *
            ‚Äñ(‚ÜëX : ‚ÑÇ) ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I)‚Äñ ‚â§ (CŒ∂ * Real.log |t| ^ 9) *
            (CM * (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2)‚Åª¬π) * X ^ œÉ‚ÇÅ:= by
      rw[XœÉ_bound]
      gcongr
    have : (CŒ∂ * Real.log |t| ^ 9) * (CM * (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2)‚Åª¬π) * X ^ œÉ‚ÇÅ = g t := by
      unfold g
      ring_nf
    linarith

  have int_with_f: ‚Äñ1 / (2 * ‚ÜëœÄ * I) *
      (I *
        ‚à´ (t : ‚Ñù) in Ioo (-T) (-3),
          -Œ∂' (‚ÜëœÉ‚ÇÅ + ‚Üët * I) / Œ∂ (‚ÜëœÉ‚ÇÅ + ‚Üët * I) * ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ‚ÇÅ + ‚Üët * I) *
            ‚ÜëX ^ (‚ÜëœÉ‚ÇÅ + ‚Üët * I))‚Äñ = ‚Äñ1 / (2 * ‚ÜëœÄ * I) *
      (I *
        ‚à´ (t : ‚Ñù) in Ioo (-T) (-3),
          f t)‚Äñ := by
      unfold f
      simp
  rw[int_with_f]
  apply (norm_mul_le _ _).trans
  have int_mulbyI_is_int : ‚ÄñI * ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), f ‚Üët‚Äñ = ‚Äñ ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), f ‚Üët‚Äñ := by
    rw [Complex.norm_mul, Complex.norm_I]
    ring
  rw[int_mulbyI_is_int]

  have norm_1over2pii_le1: ‚Äñ1 / (2 * ‚ÜëœÄ * I)‚Äñ ‚â§ 1 := by
    simp
    have pi_gt_3 : Real.pi > 3 := by
      exact pi_gt_three
    have pi_pos : 0 < œÄ := by linarith [pi_gt_3]
    have abs_pi_inv_le : |œÄ|‚Åª¬π ‚â§ (1 : ‚Ñù) := by
      rw [abs_of_pos pi_pos]
      have h : 1 = œÄ * œÄ‚Åª¬π := by
        field_simp
      rw[h]
      nth_rw 1 [‚Üê one_mul œÄ‚Åª¬π]
      apply mul_le_mul_of_nonneg_right
      ¬∑ linarith
      ¬∑ exact inv_nonneg.mpr (le_of_lt pi_pos)
    have : (0 : ‚Ñù) < (2 : ‚Ñù) := by norm_num
    have h_half_le_one : (2 : ‚Ñù)‚Åª¬π ‚â§ 1 := by norm_num
    linarith

  have : ‚Äñ1 / (2 * ‚ÜëœÄ * I)‚Äñ * ‚Äñ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), f ‚Üët‚Äñ ‚â§  ‚Äñ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), f ‚Üët‚Äñ := by
    apply mul_le_of_le_one_left
    ¬∑ apply norm_nonneg
    ¬∑ exact norm_1over2pii_le1
  apply le_trans this
  have : ‚Äñ ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), f ‚Üët‚Äñ ‚â§  ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), ‚Äñf ‚Üë t‚Äñ := by
    apply norm_integral_le_integral_norm
  apply le_trans this

  have norm_f_nonneg: ‚àÄ t, ‚Äñf t‚Äñ ‚â• 0 := by
    exact fun t ‚Ü¶ norm_nonneg (f t)

  have g_cont : ContinuousOn g (Icc (-T) (-3)) := by
    unfold g
    refine ContinuousOn.mul ?_ ?_
    refine ContinuousOn.mul ?_ ?_
    refine ContinuousOn.mul ?_ ?_
    refine ContinuousOn.mul ?_ ?_
    ¬∑ exact continuousOn_const
    ¬∑ exact continuousOn_const
    ¬∑ refine ContinuousOn.pow ?_ 9
      refine ContinuousOn.log ?_ ?_
      ¬∑ refine Continuous.continuousOn ?_
        exact _root_.continuous_abs
      ¬∑ intro t ht
        have h1 := ht.1
        have h2 := ht.2
        by_contra!
        have : t = 0 := by
          exact abs_eq_zero.mp this
        rw[this] at h2
        absurd
        h2
        linarith
    ¬∑ refine ContinuousOn.inv‚ÇÄ ?_ ?_
      ¬∑ refine ContinuousOn.mul ?_ ?_
        ¬∑ exact continuousOn_const
        ¬∑ refine ContinuousOn.pow ?_ 2
          refine ContinuousOn.norm ?_
          refine ContinuousOn.add ?_ ?_
          ¬∑ exact continuousOn_const
          ¬∑ refine ContinuousOn.mul ?_ ?_
            ¬∑ refine continuousOn_of_forall_continuousAt ?_
              intro x hx
              exact continuous_ofReal.continuousAt
            ¬∑ exact continuousOn_const
      ¬∑ intro x hx
        have norm_sq_pos : ‚Äñ(œÉ‚ÇÅ : ‚ÑÇ) + x * Complex.I‚Äñ ^ 2 = œÉ‚ÇÅ ^ 2 + x ^ 2 := by
          rw [Complex.sq_norm]
          exact normSq_add_mul_I œÉ‚ÇÅ x
        have : 0 < œÉ‚ÇÅ ^ 2 + x ^ 2 := by
          apply add_pos_of_pos_of_nonneg
          ¬∑ exact sq_pos_of_pos œÉ‚ÇÅpos
          ¬∑ exact sq_nonneg x
        apply mul_ne_zero
        ¬∑ linarith
        ¬∑ rw [norm_sq_pos]
          exact ne_of_gt this
    ¬∑ exact continuousOn_const

  have g_integrable_Icc : IntegrableOn g (Icc (-T) (-3)) volume := by
    exact ContinuousOn.integrableOn_Icc g_cont

  have g_integrable_Ioo : IntegrableOn g (Ioo (-T) (-3)) volume := by
    apply MeasureTheory.IntegrableOn.mono_set g_integrable_Icc
    exact Ioo_subset_Icc_self

  have int_normf_le_int_g: ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), ‚Äñf ‚Üët‚Äñ
                        ‚â§ ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), g ‚Üët := by

    by_cases h_int : IntervalIntegrable (fun t : ‚Ñù ‚Ü¶ ‚Äñf t‚Äñ) volume (-T) (-3)
    ¬∑ have f_int : IntegrableOn (fun (t : ‚Ñù) ‚Ü¶ ‚Äñf t‚Äñ) (Ioo (-T : ‚Ñù) (-3 : ‚Ñù)) volume := by
        have hle : -T ‚â§ -3 := by linarith
        exact (intervalIntegrable_iff_integrableOn_Ioo_of_le hle).mp h_int
      apply MeasureTheory.setIntegral_mono_on
      exact f_int
      exact g_integrable_Ioo
      exact measurableSet_Ioo
      intro t ht
      apply bound_integral
      have : |t| = -t := by
        refine abs_of_neg ?_
        linarith [ht.2]
      have abs_tgt3 : 3 < |t| := by
        rw[this]
        linarith[ht.2]
      have abs_tltX : |t| < T := by
        rw[this]
        linarith[ht.1]
      constructor
      ¬∑ linarith
      ¬∑ linarith
    ¬∑ have : ‚à´ (t : ‚Ñù) in -T..-3, ‚Äñf ‚Üë t‚Äñ = ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), ‚Äñf ‚Üët‚Äñ  := by
        rw [intervalIntegral.integral_of_le (by linarith)]
        exact MeasureTheory.integral_Ioc_eq_integral_Ioo
      have : ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), ‚Äñf ‚Üët‚Äñ = 0 := by
        rw [‚Üê this]
        exact intervalIntegral.integral_undef h_int
      rw [this]
      apply MeasureTheory.setIntegral_nonneg
      ¬∑ exact measurableSet_Ioo
      ¬∑ intro t ht
        have abst_negt : |t| = -t := by
          refine abs_of_neg ?_
          linarith [ht.2]
        have tbounds1 : 3 < |t| ‚àß |t| < T := by
          rw[abst_negt]
          constructor
          ¬∑ linarith [ht.2]
          ¬∑ linarith [ht.1]
        unfold g
        apply mul_nonneg
        apply mul_nonneg
        apply mul_nonneg
        apply mul_nonneg
        ¬∑ linarith
        ¬∑ linarith
        ¬∑ have : 0 ‚â§ Real.log |t| := by
            apply Real.log_nonneg
            linarith [tbounds1.1]
          positivity
        ¬∑ field_simp
          apply div_nonneg
          ¬∑ linarith
          ¬∑ apply mul_nonneg
            ¬∑ linarith
            ¬∑ rw [Complex.sq_norm]
              exact normSq_nonneg (‚ÜëœÉ‚ÇÅ + ‚Üët * I)
        ¬∑ apply Real.rpow_nonneg
          linarith

  apply le_trans int_normf_le_int_g
  unfold g

  have : X ^ œÉ‚ÇÅ = X ^ (1 - A / Real.log T ) := by
    rfl
  rw[this]

  have : X ^ (1 - A / Real.log T) = X * X ^ (- A / Real.log T) := by
    have hX : X > 0 := by linarith
    simp only [Real.rpow_sub hX, Real.rpow_one]
    have h‚ÇÅ : X ^ (-A / Real.log T) * X ^ (A / Real.log T) = 1 := by
      rw [‚Üê Real.rpow_add hX]
      ring_nf
      exact rpow_zero X
    field_simp
    rw[mul_assoc, h‚ÇÅ]
    ring

  rw[this]


  have Bound_of_log_int: ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2) ‚â§ Cint / Œµ := by
    have : ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2)
        = (1 / Œµ) * ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 / ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2 := by
      rw [‚Üê integral_const_mul]
      congr with t
      field_simp [Œµgt0]
    rw[this]
    have normsquared : ‚àÄ (t : ‚Ñù), ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2 = œÉ‚ÇÅ ^ 2 + t ^ 2 := by
      intro t
      simp only [Complex.sq_norm]
      exact normSq_add_mul_I œÉ‚ÇÅ t

    have : ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 / ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2
          = ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2) := by
      simp_rw [normsquared]

    have bound : ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 / ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2 ‚â§ Cint := by
      rw [this]
      have : ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2)
            ‚â§ ‚à´ t in Ioo (-T) (-3), Real.log |t| ^ 9 /  t ^ 2 := by
        refine setIntegral_mono_on ?_ ?_ ?_ ?_
        ¬∑
          have cont : ContinuousOn (fun t ‚Ü¶ Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2)) (Set.Icc (-T) (-3)) := by
            refine ContinuousOn.div ?_ ?_ ?_
            ¬∑ refine ContinuousOn.pow ?_ 9
              refine ContinuousOn.log ?_ ?_
              ¬∑ refine continuousOn_of_forall_continuousAt ?_
                intro x hx
                refine Continuous.continuousAt ?_
                exact _root_.continuous_abs
              ¬∑ intro x hx
                have h1 : x ‚â§ -3 := hx.2
                have xne0 : x ‚â† 0 := by linarith
                exact abs_ne_zero.mpr xne0
            ¬∑ refine ContinuousOn.add ?_ ?_
              ¬∑ exact continuousOn_const
              ¬∑ refine ContinuousOn.pow ?_ 2
                exact continuousOn_id' (Icc (-T) (-3))
            ¬∑ intro t ht
              have h1 : t ‚â§ -3 := ht.2
              have h2 : t ‚â† 0 := by linarith
              have h3 : 0 < t ^ 2 := pow_two_pos_of_ne_zero h2
              have h4 : 0 < œÉ‚ÇÅ ^ 2 := sq_pos_of_pos œÉ‚ÇÅpos
              linarith [h3, h4]
          have int_Icc : IntegrableOn (fun t ‚Ü¶ Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2)) (Icc (-T) (-3)) volume := by
            exact ContinuousOn.integrableOn_Icc cont
          have int_Ioo : IntegrableOn (fun t ‚Ü¶ Real.log |t| ^ 9 / (œÉ‚ÇÅ ^ 2 + t ^ 2)) (Ioo (-T) (-3)) volume := by
            apply MeasureTheory.IntegrableOn.mono_set int_Icc
            exact Ioo_subset_Icc_self
          exact int_Ioo
        ¬∑ have cont : ContinuousOn (fun t ‚Ü¶ Real.log |t| ^ 9 / t ^ 2) (Set.Icc (-T) (-3)) := by
            refine ContinuousOn.div ?_ ?_ ?_
            ¬∑ refine ContinuousOn.pow ?_ 9
              refine ContinuousOn.log ?_ ?_
              ¬∑ refine continuousOn_of_forall_continuousAt ?_
                intro x hx
                refine Continuous.continuousAt ?_
                exact _root_.continuous_abs
              ¬∑ intro x hx
                have h1 : x ‚â§ -3 := hx.2
                have xne0 : x ‚â† 0 := by linarith
                exact abs_ne_zero.mpr xne0
            ¬∑ refine ContinuousOn.pow ?_ 2
              exact continuousOn_id' (Icc (-T) (-3))
            ¬∑ intro t ht
              have h1 : t ‚â§ -3 := ht.2
              have tne0 : t ‚â† 0 := by linarith
              exact pow_ne_zero 2 tne0
          have int_Icc : IntegrableOn (fun t ‚Ü¶ Real.log |t| ^ 9 / t ^ 2) (Icc (-T) (-3)) volume := by
            exact ContinuousOn.integrableOn_Icc cont
          have int_Ioo : IntegrableOn (fun t ‚Ü¶ Real.log |t| ^ 9 / t ^ 2) (Ioo (-T) (-3)) volume := by
            apply MeasureTheory.IntegrableOn.mono_set int_Icc
            exact Ioo_subset_Icc_self
          exact int_Ioo
        ¬∑ exact measurableSet_Ioo
        ¬∑ intro x hx
          have xneg : x < 0 := by linarith[hx.2]
          have absx : |x| = -x := abs_of_neg xneg
          have h1 : 3 < |x| ‚àß |x| < T := by
            rw[absx]
            constructor
            ¬∑ linarith [hx.2]
            ¬∑ linarith [hx.1]
          exact quotient_bound x (t_bounds x hx)
      apply le_trans this
      have : ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / t ^ 2
            = ‚à´ (t : ‚Ñù) in Ioo 3 T, Real.log t ^ 9 / t ^ 2 := by
        have eq_integrand : ‚àÄ (t : ‚Ñù), t ‚àà Ioo (-T) (-3) ‚Üí (Real.log |t|) ^ 9 / t ^ 2 = (Real.log (-t)) ^ 9 / (-t) ^ 2 := by
          intro t ht
          have tneg : t < 0 := by linarith[ht.2]
          have : |t| = -t := abs_of_neg tneg
          rw [this, neg_sq]

        have : ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / t ^ 2
              = ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log (-t) ^ 9 / (-t) ^ 2 := by
          exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo eq_integrand

        rw [this]

        have interval_to_Ioo1 : ‚à´ (t : ‚Ñù) in -T..-3, Real.log (-t) ^ 9 / (-t) ^ 2
                        = ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log (-t) ^ 9 / (-t) ^ 2 := by
          rw [intervalIntegral.integral_of_le (by linarith)]
          exact MeasureTheory.integral_Ioc_eq_integral_Ioo

        have interval_to_Ioo2 : ‚à´ (t : ‚Ñù) in (3)..(T), Real.log t ^ 9 / t ^ 2
                    = ‚à´ (t : ‚Ñù) in Ioo 3 T, Real.log t ^ 9 / t ^ 2 := by
          rw [intervalIntegral.integral_of_le (by linarith)]
          exact MeasureTheory.integral_Ioc_eq_integral_Ioo

        rw [‚Üê interval_to_Ioo1, ‚Üê interval_to_Ioo2]
        rw [intervalIntegral.integral_comp_neg (fun (t : ‚Ñù) ‚Ü¶ Real.log (t) ^ 9 / (t) ^ 2)]
        simp
      rw [this]
      have : ‚à´ (t : ‚Ñù) in Ioo 3 T, Real.log t ^ 9 / t ^ 2 < Cint := by
        exact Cinthyp T Tgt3
      linarith
    rw [ mul_comm]
    rw [‚Üê mul_div_assoc, mul_one]
    exact (div_le_div_iff_of_pos_right Œµgt0).mpr bound


  have factor_out_constants :
  ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), CŒ∂ * CM * Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2) * (X * X ^ (-A / Real.log T ))
  = CŒ∂ * CM * (X * X ^ (-A / Real.log T)) * ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2) := by
     rw [mul_assoc, ‚Üê mul_assoc (CŒ∂ * CM), ‚Üê mul_assoc]
     field_simp
     rw [‚Üê integral_const_mul]
     apply MeasureTheory.setIntegral_congr_fun measurableSet_Ioo
     intro t ht
     ring

  rw [factor_out_constants]

  have : CŒ∂ * CM * (X * X ^ (-A / Real.log T)) * ‚à´ (t : ‚Ñù) in Ioo (-T) (-3), Real.log |t| ^ 9 / (Œµ * ‚Äñ‚ÜëœÉ‚ÇÅ + ‚Üët * I‚Äñ ^ 2)
        ‚â§ CŒ∂ * CM * ((X : ‚Ñù) * X ^ (-A / Real.log T)) * (Cint / Œµ) := by
    apply mul_le_mul_of_nonneg_left
    ¬∑ exact Bound_of_log_int
    ¬∑ have hpos : 0 < X * X ^ (-A / Real.log T) := by
        apply mul_pos
        ¬∑ linarith
        ¬∑ apply Real.rpow_pos_of_pos
          linarith
      apply mul_nonneg
      ¬∑ apply mul_nonneg
        ¬∑ linarith
        ¬∑ linarith
      ¬∑ linarith [hpos]

  apply le_trans this
  ring_nf
  field_simp


lemma I7Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {A CŒ∂ : ‚Ñù} (hCŒ∂ : LogDerivZetaHasBound A CŒ∂) (CŒ∂pos : 0 < CŒ∂) (hA : A ‚àà Ioc 0 (1 / 2))
    : ‚àÉ (C : ‚Ñù) (_ : 0 < C),
    ‚àÄ (X : ‚Ñù) (_ : 3 < X) {Œµ : ‚Ñù} (_ : 0 < Œµ)
    (_ : Œµ < 1) {T : ‚Ñù} (_ : 3 < T),
    let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
    ‚ÄñI‚Çá SmoothingF Œµ T X œÉ‚ÇÅ‚Äñ ‚â§ C * X * X ^ (- A / (Real.log T)) / Œµ := by
  obtain ‚ü®C, Cpos, bound‚ü© := I3Bound suppSmoothingF ContDiffSmoothingF hCŒ∂ CŒ∂pos hA
  refine ‚ü®C, Cpos, fun X X_gt Œµ Œµpos Œµ_lt_one T T_gt ‚Ü¶ ?_‚ü©
  specialize bound X X_gt Œµpos Œµ_lt_one T_gt
  intro œÉ‚ÇÅ
  rwa [I7I3 (by linarith), norm_conj]
/-%%
\begin{proof}\uses{MellinOfSmooth1b, LogDerivZetaBnd, IntegralofLogx^n/x^2Bounded, I3, I7}\leanok
Unfold the definitions and apply the triangle inequality.
$$
\left|I_{3}(\nu, \epsilon, X, T, \sigma_1)\right| =
\left|\frac{1}{2\pi i} \int_{-T}^3
\left(\frac{-\zeta'}\zeta(\sigma_1 + t i) \right)
\mathcal M(\widetilde 1_\epsilon)(\sigma_1 + t i)
X^{\sigma_1 + t i}
\ i \ dt
\right|
$$
$$\leq
\frac{1}{2\pi}
\int_{-T}^3
C \cdot \log t ^ 9
\frac{C'}{\epsilon|\sigma_1 + t i|^2}
X^{\sigma_1}
 \ dt
,
$$
where we used Theorems \ref{MellinOfSmooth1b} and \ref{LogDerivZetaBnd}.
Now we estimate $X^{\sigma_1} = X \cdot X^{-A/ \log T^9}$, and the integral is absolutely bounded.
\end{proof}
%%-/



/-%%
\begin{lemma}[I4Bound]\label{I4Bound}\lean{I4Bound}\leanok
We have that
$$
\left|I_{4}(\nu, \epsilon, X, \sigma_1, \sigma_2)\right| \ll \frac{X}{\epsilon}\,
 X^{-\frac{A}{(\log T)^9}}
.
$$
Same with $I_6$.
\end{lemma}
%%-/

lemma I4Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    --(SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    --(mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {œÉ‚ÇÇ : ‚Ñù} (h_logDeriv_holo : LogDerivZetaIsHoloSmall œÉ‚ÇÇ) (hœÉ‚ÇÇ : œÉ‚ÇÇ ‚àà Ioo 0 1)
    {A : ‚Ñù} --{CŒ∂ : ‚Ñù} --(hCŒ∂ : LogDerivZetaHasBound A CŒ∂) (CŒ∂pos : 0 < CŒ∂)
    (hA : A ‚àà Ioc 0 (1 / 2)) :
    ‚àÉ (C : ‚Ñù) (_ : 0 ‚â§ C) (Tlb : ‚Ñù) (_ : 3 < Tlb),
    ‚àÄ (X : ‚Ñù) (_ : 3 < X)
    {Œµ : ‚Ñù} (_ : 0 < Œµ) (_ : Œµ < 1)
    {T : ‚Ñù} (_ : Tlb < T),
    let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
    ‚ÄñI‚ÇÑ SmoothingF Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ ‚â§ C * X * X ^ (- A / (Real.log T)) / Œµ := by

  have reOne : re 1 = 1 := by exact rfl
  have imOne : im 1 = 0 := by exact rfl
  have reThree : re 3 = 3 := by exact rfl
  have imThree : im 3 = 0 := by exact rfl

  have elt3 : Real.exp 1 < 3 := by
    linarith[Real.exp_one_lt_d9]

  unfold I‚ÇÑ SmoothedChebyshevIntegrand

  let S : Set ‚Ñù := (fun (t : ‚Ñù) ‚Ü¶ ‚Üë‚Äñ-Œ∂' (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) / Œ∂ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I)‚Äñ‚Çä) '' Icc 0 1
  let C' : ‚Ñù := sSup S
  have bddAboveS : BddAbove S := by
    refine IsCompact.bddAbove ?_
    unfold S
    refine IsCompact.image_of_continuousOn ?_ ?_
    ¬∑ exact isCompact_Icc
    ¬∑ refine ContinuousOn.norm ?_
      have : (fun (t : ‚Ñù) ‚Ü¶ -Œ∂' (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) / Œ∂ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I)) =
        (fun (t : ‚Ñù) ‚Ü¶ -(Œ∂' (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) / Œ∂ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I))) := by
        apply funext
        intro x
        apply neg_div
      rw[this]
      refine ContinuousOn.neg ?_
      have : (fun (t : ‚Ñù) ‚Ü¶ Œ∂' (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) / Œ∂ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I)) =
        ((Œ∂' / Œ∂) ‚àò (fun (t : ‚Ñù) ‚Ü¶ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I))) := by exact rfl
      rw[this]
      apply h_logDeriv_holo.continuousOn.comp' (by fun_prop)
      unfold MapsTo
      intro x xInIcc
      simp only [neg_le_self_iff, Nat.ofNat_nonneg, uIcc_of_le, mem_diff, mem_singleton_iff]
      have : ¬¨‚ÜëœÉ‚ÇÇ + ‚Üëx * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I = 1 := by
        by_contra h
        rw[Complex.ext_iff, sub_re, add_re, sub_im, add_im] at h
        repeat rw[mul_im] at h
        repeat rw[mul_re] at h
        rw[sub_im, sub_re, reOne, imOne, reThree, imThree, I_im, I_re] at h
        repeat rw[ofReal_re] at h
        repeat rw[ofReal_im] at h
        ring_nf at h
        obtain ‚ü®_, ripGoal‚ü© := h
        have : -3 ‚â† 0 := by norm_num
        linarith
      refine ‚ü®?_, this‚ü©
      rw [mem_reProdIm]
      simp only [sub_re, add_re, ofReal_re, mul_re, one_re, ofReal_im, sub_im, one_im, sub_self,
        mul_zero, sub_zero, re_ofNat, I_re, im_ofNat, I_im, mul_one, add_im, mul_im, zero_mul,
        add_zero, zero_sub, mem_Icc, le_refl, neg_le_self_iff, Nat.ofNat_nonneg, and_self, and_true]
      rw [Set.uIcc_of_le]
      ¬∑ rw [mem_Icc]
        constructor
        ¬∑ simp only [le_add_iff_nonneg_right]
          apply mul_nonneg
          ¬∑ exact xInIcc.1
          ¬∑ linarith [hœÉ‚ÇÇ.2]
        ¬∑ have : œÉ‚ÇÇ + x * (1 - œÉ‚ÇÇ) = œÉ‚ÇÇ * (1 - x) + x := by ring
          rw [this]
          clear this
          have : (2 : ‚Ñù) = 1 * 1 + 1 := by norm_num
          rw [this]
          clear this
          gcongr
          ¬∑ linarith [xInIcc.2]
          ¬∑ exact hœÉ‚ÇÇ.2.le
          ¬∑ linarith [xInIcc.1]
          ¬∑ exact xInIcc.2
      ¬∑ linarith [hœÉ‚ÇÇ.2]

  have CPrimeNonneg : 0 ‚â§ C' := by
    apply Real.sSup_nonneg
    intro x x_in_S
    obtain ‚ü®t, ht, rfl‚ü© := x_in_S
    exact NNReal.coe_nonneg _

  obtain ‚ü®D, Dpos, MellinSmooth1bBound‚ü© := MellinOfSmooth1b ContDiffSmoothingF suppSmoothingF
  let C : ‚Ñù := C' * D / sInf ((fun t => ‚Äñ œÉ‚ÇÇ + (t : ‚Ñù) * (1 - œÉ‚ÇÇ) - 3 * I ‚Äñ‚Çä ^ 2) '' Set.Icc 0 1)
  use C
  have sInfPos : 0 < sInf ((fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä ^ 2) '' Icc 0 1) := by
    refine (IsCompact.lt_sInf_iff_of_continuous ?_ ?_ ?_ 0).mpr ?_
    ¬∑ exact isCompact_Icc
    ¬∑ exact Nonempty.of_subtype
    ¬∑ have : (fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä ^ 2) =
        (fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä * ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä) := by
        apply funext
        intro x
        rw[pow_two]
      rw[this]
      have : ContinuousOn (fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä) (Icc 0 1) := by
        refine ContinuousOn.nnnorm ?_
        refine ContinuousOn.sub ?_ (by exact continuousOn_const)
        refine ContinuousOn.add (by exact continuousOn_const) ?_
        exact ContinuousOn.mul (by exact Complex.continuous_ofReal.continuousOn) (by exact continuousOn_const)
      exact ContinuousOn.mul (by exact this) (by exact this)
    ¬∑ intro x xLoc
      apply pow_pos
      have temp : |(‚ÜëœÉ‚ÇÇ + ‚Üëx * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I).im| ‚â§
        ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üëx * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä := by apply Complex.abs_im_le_norm
      rw[sub_im, add_im, mul_im, mul_im, I_re, I_im, sub_im, sub_re] at temp
      repeat rw[ofReal_re] at temp
      repeat rw[ofReal_im] at temp
      rw[reThree, imOne] at temp
      ring_nf at temp ‚ä¢
      rw[abs_of_neg, neg_neg] at temp
      ¬∑ have : (3 : NNReal) ‚â§ ‚Äñ‚ÜëœÉ‚ÇÇ - ‚ÜëœÉ‚ÇÇ * ‚Üëx + (‚Üëx - I * 3)‚Äñ‚Çä := by exact temp
        positivity
      ¬∑ rw[neg_lt_zero]
        norm_num
  have CNonneg : 0 ‚â§ C := by
    unfold C
    apply mul_nonneg
    ¬∑ exact mul_nonneg (by exact CPrimeNonneg) (by exact Dpos.le)
    ¬∑ rw[inv_nonneg]
      norm_cast
      convert sInfPos.le using 5
      norm_cast
  use CNonneg

  let Tlb : ‚Ñù := max 4 (max (rexp A) (rexp (A / (1 - œÉ‚ÇÇ))))
  use Tlb

  have : 3 < Tlb := by
    unfold Tlb
    rw[lt_max_iff]
    refine Or.inl ?_
    norm_num
  use this

  intro X X_gt_three Œµ Œµ_pos Œµ_lt_one

  intro T T_gt_Tlb œÉ‚ÇÅ
  have œÉ‚ÇÇ_le_œÉ‚ÇÅ : œÉ‚ÇÇ ‚â§ œÉ‚ÇÅ := by
    have logTlb_pos : 0 < Real.log Tlb := by
      rw[‚Üê Real.log_one]
      exact log_lt_log (by norm_num) (by linarith)
    have logTlb_nonneg : 0 ‚â§ Real.log Tlb := by exact le_of_lt (by exact logTlb_pos)
    have expr_nonneg : 0 ‚â§ A / (1 - œÉ‚ÇÇ) := by
      apply div_nonneg
      ¬∑ linarith [hA.1]
      ¬∑ rw[sub_nonneg]
        exact le_of_lt hœÉ‚ÇÇ.2
    have temp : œÉ‚ÇÇ ‚â§ 1 - A / Real.log Tlb := by
      have : rexp (A / (1 - œÉ‚ÇÇ)) ‚â§ Tlb := by
        unfold Tlb
        apply le_max_of_le_right
        apply le_max_right
      rw[‚Üê Real.le_log_iff_exp_le] at this
      ¬∑ rw[div_le_iff‚ÇÄ, mul_comm, ‚Üê div_le_iff‚ÇÄ] at this
        ¬∑ linarith
        ¬∑ exact logTlb_pos
        ¬∑ rw[sub_pos]
          exact hœÉ‚ÇÇ.2
      ¬∑ positivity
    have : 1 - A / Real.log Tlb ‚â§ 1 - A / Real.log T := by
      apply sub_le_sub (by rfl)
      apply div_le_div‚ÇÄ
      ¬∑ exact le_of_lt (by exact hA.1)
      ¬∑ rfl
      ¬∑ exact logTlb_pos
      ¬∑ apply log_le_log (by positivity)
        exact le_of_lt (by exact T_gt_Tlb)
    exact le_trans temp this
  have minœÉ‚ÇÇœÉ‚ÇÅ : min œÉ‚ÇÇ œÉ‚ÇÅ = œÉ‚ÇÇ := by exact min_eq_left (by exact œÉ‚ÇÇ_le_œÉ‚ÇÅ)
  have maxœÉ‚ÇÇœÉ‚ÇÅ : max œÉ‚ÇÇ œÉ‚ÇÅ = œÉ‚ÇÅ := by exact max_eq_right (by exact œÉ‚ÇÇ_le_œÉ‚ÇÅ)
  have œÉ‚ÇÅ_lt_one : œÉ‚ÇÅ < 1 := by
    rw[‚Üê sub_zero 1]
    unfold œÉ‚ÇÅ
    apply sub_lt_sub_left
    apply div_pos (by exact hA.1)
    rw[‚Üê Real.log_one]
    exact log_lt_log (by norm_num) (by linarith)

  rw[norm_mul, ‚Üê one_mul C]
  have : 1 * C * X * X ^ (-A / Real.log T) / Œµ = 1 * (C * X * X ^ (-A / Real.log T) / Œµ) := by ring
  rw[this]
  apply mul_le_mul
  ¬∑ rw[norm_div, norm_one]
    repeat rw[norm_mul]
    rw[Complex.norm_two, Complex.norm_real, Real.norm_of_nonneg, Complex.norm_I, mul_one]
    have : 1 / (2 * œÄ) < 1 / 6 := by
      rw[one_div_lt_one_div]
      ¬∑ refine (div_lt_iff‚ÇÄ' ?_).mp ?_
        norm_num
        ring_nf
        refine gt_iff_lt.mpr ?_
        exact Real.pi_gt_three
      ¬∑ positivity
      ¬∑ norm_num
    apply le_of_lt
    exact lt_trans this (by norm_num)
    exact pi_nonneg
  ¬∑ let f : ‚Ñù ‚Üí ‚ÑÇ := fun œÉ ‚Ü¶ (-Œ∂' (‚ÜëœÉ - 3 * I) / Œ∂ (‚ÜëœÉ - 3 * I) * ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ - 3 * I) * ‚ÜëX ^ (‚ÜëœÉ - 3 * I))
    have temp : ‚Äñ‚à´ (œÉ : ‚Ñù) in œÉ‚ÇÇ..œÉ‚ÇÅ, -Œ∂' (‚ÜëœÉ - 3 * I) / Œ∂ (‚ÜëœÉ - 3 * I) * ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (‚ÜëœÉ - 3 * I) * ‚ÜëX ^ (‚ÜëœÉ - 3 * I)‚Äñ ‚â§
      C * X * X ^ (-A / Real.log T) / Œµ * |œÉ‚ÇÅ - œÉ‚ÇÇ| := by
      have : ‚àÄ x ‚àà Set.uIoc œÉ‚ÇÇ œÉ‚ÇÅ, ‚Äñf x‚Äñ ‚â§ C * X * X ^ (-A / Real.log T) / Œµ := by
        intro x xInIoc
        let t : ‚Ñù := (x - œÉ‚ÇÇ) / (1 - œÉ‚ÇÇ)
        have tInIcc : t ‚àà Icc 0 1 := by
          unfold t
          constructor
          ¬∑ apply div_nonneg
            ¬∑ rw[sub_nonneg]
              unfold uIoc at xInIoc
              rw[minœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
              exact le_of_lt (by exact xInIoc.1)
            ¬∑ rw[sub_nonneg]
              apply le_of_lt (by exact hœÉ‚ÇÇ.2)
          ¬∑ rw[div_le_one]
            ¬∑ refine sub_le_sub ?_ (by rfl)
              unfold uIoc at xInIoc
              rw[maxœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
              apply le_trans xInIoc.2
              exact le_of_lt (by exact œÉ‚ÇÅ_lt_one)
            ¬∑ rw[sub_pos]
              exact hœÉ‚ÇÇ.2
        have tExpr : (‚ÜëœÉ‚ÇÇ + t * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) = (‚Üëx - 3 * I) := by
          unfold t
          simp only [ofReal_div, ofReal_sub, ofReal_one, sub_left_inj]
          rw[div_mul_comm, div_self]
          ¬∑ simp only [one_mul, add_sub_cancel]
          ¬∑ refine sub_ne_zero_of_ne ?_
            apply Ne.symm
            rw[Complex.ofReal_ne_one]
            exact ne_of_lt (by exact hœÉ‚ÇÇ.2)
        unfold f
        simp only [Complex.norm_mul, norm_neg]
        have : C * X * X ^ (-A / Real.log T) / Œµ =
          (C / Œµ) * (X * X ^ (-A / Real.log T)) := by ring
        rw[this]
        have temp : ‚Äñ-Œ∂' (‚Üëx - 3 * I) / Œ∂ (‚Üëx - 3 * I)‚Äñ * ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚Üëx - 3 * I)‚Äñ ‚â§
          C / Œµ := by
          unfold C
          rw[div_div]
          nth_rewrite 2 [div_eq_mul_inv]
          have temp : ‚Äñ-Œ∂' (‚Üëx - 3 * I) / Œ∂ (‚Üëx - 3 * I)‚Äñ ‚â§ C' := by
            unfold C'
            have : ‚Äñ-Œ∂' (‚Üëx - 3 * I) / Œ∂ (‚Üëx - 3 * I)‚Äñ ‚àà
              (fun (t : ‚Ñù) ‚Ü¶ ‚Üë‚Äñ-Œ∂' (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I) / Œ∂ (‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I)‚Äñ‚Çä) '' Icc 0 1 := by
              rw[Set.mem_image]
              use t
              constructor
              ¬∑ exact tInIcc
              ¬∑ rw[tExpr]
                rfl
            exact le_csSup (by exact bddAboveS) (by exact this)
          have : ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚Üëx - 3 * I)‚Äñ ‚â§
            D * ((sInf ((fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä ^ 2) '' Icc 0 1)) * Œµ)‚Åª¬π := by
            nth_rewrite 3 [mul_comm]
            let s : ‚ÑÇ := x - 3 * I
            have : ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚Üëx - 3 * I) =
              ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) s := by exact rfl
            rw[this]
            have temp : œÉ‚ÇÇ ‚â§ s.re := by
              unfold s
              rw[sub_re, mul_re, I_re, I_im, reThree, imThree, ofReal_re]
              ring_nf
              apply le_of_lt
              unfold uIoc at xInIoc
              rw[minœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
              exact xInIoc.1
            have : s.re ‚â§ 2 := by
              unfold s
              rw[sub_re, mul_re, I_re, I_im, reThree, imThree, ofReal_re]
              ring_nf
              have : x < 1 := by
                unfold uIoc at xInIoc
                rw[maxœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
                exact lt_of_le_of_lt xInIoc.2 œÉ‚ÇÅ_lt_one
              linarith
            have temp : ‚Äñùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) s‚Äñ ‚â§ D * (Œµ * ‚Äñs‚Äñ ^ 2)‚Åª¬π := by
              exact MellinSmooth1bBound œÉ‚ÇÇ hœÉ‚ÇÇ.1 s temp this Œµ Œµ_pos Œµ_lt_one
            have : D * (Œµ * ‚Äñs‚Äñ ^ 2)‚Åª¬π ‚â§ D * (Œµ * ‚Üë(sInf ((fun (t : ‚Ñù) ‚Ü¶ ‚Äñ‚ÜëœÉ‚ÇÇ + ‚Üët * (1 - ‚ÜëœÉ‚ÇÇ) - 3 * I‚Äñ‚Çä ^ 2) '' Icc 0 1)))‚Åª¬π := by
              refine mul_le_mul (by rfl) ?_ ?_ (by exact le_of_lt (by exact Dpos))
              ¬∑ rw[inv_le_inv‚ÇÄ]
                ¬∑ apply mul_le_mul (by rfl)
                  ¬∑ rw[NNReal.coe_sInf]
                    apply csInf_le
                    ¬∑ apply NNReal.bddBelow_coe
                    ¬∑ unfold s
                      rw[Set.mem_image]
                      let xNorm : NNReal := ‚Äñx - 3 * I‚Äñ‚Çä ^ 2
                      use xNorm
                      constructor
                      ¬∑ rw[Set.mem_image]
                        use t
                        exact ‚ü®tInIcc, by rw[tExpr]‚ü©
                      ¬∑ rfl
                  ¬∑ exact le_of_lt (by exact sInfPos)
                  ¬∑ exact le_of_lt (by exact Œµ_pos)
                ¬∑ apply mul_pos (Œµ_pos)
                  refine sq_pos_of_pos ?_
                  refine norm_pos_iff.mpr ?_
                  refine ne_zero_of_re_pos ?_
                  unfold s
                  rw[sub_re, mul_re, I_re, I_im, reThree, imThree, ofReal_re]
                  ring_nf
                  unfold uIoc at xInIoc
                  rw[minœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
                  exact lt_trans hœÉ‚ÇÇ.1 xInIoc.1
                ¬∑ exact mul_pos (Œµ_pos) (sInfPos)
              ¬∑ rw[inv_nonneg]
                apply mul_nonneg (by exact le_of_lt (by exact Œµ_pos))
                exact sq_nonneg ‚Äñs‚Äñ
            exact le_trans temp this
          rw[mul_assoc]
          apply mul_le_mul (by exact temp) (by exact this)
          ¬∑ have this : 0 ‚â§ |(ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (‚Üëx - 3 * I)).re| := by
              apply abs_nonneg
            exact le_trans this (by refine Complex.abs_re_le_norm ?_)
          ¬∑ exact CPrimeNonneg
        have : ‚Äñ(X : ‚ÑÇ) ^ (‚Üëx - 3 * I)‚Äñ ‚â§
          X * X ^ (-A / Real.log T) := by
          nth_rewrite 2 [‚Üê Real.rpow_one X]
          rw[‚Üê Real.rpow_add]
          ¬∑ rw[Complex.norm_cpow_of_ne_zero]
            ¬∑ rw[sub_re, sub_im, mul_re, mul_im, ofReal_re, ofReal_im, I_re, I_im, reThree, imThree]
              ring_nf
              rw[Complex.norm_of_nonneg]
              ¬∑ rw[Complex.arg_ofReal_of_nonneg]

                ¬∑ have one_inv: (1‚Åª¬π : ‚Ñù) = ( 1 : ‚Ñù) := by norm_num
                  rw[zero_mul, neg_zero, Real.exp_zero, one_inv, mul_one]
                  refine rpow_le_rpow_of_exponent_le ?_ ?_
                  ¬∑ linarith
                  ¬∑ unfold uIoc at xInIoc
                    rw[maxœÉ‚ÇÇœÉ‚ÇÅ] at xInIoc
                    unfold œÉ‚ÇÅ at xInIoc
                    rw [‚Üêdiv_eq_mul_inv]
                    ring_nf at xInIoc ‚ä¢
                    exact xInIoc.2
                ¬∑ positivity
              ¬∑ positivity
            ¬∑ refine ne_zero_of_re_pos ?_
              rw[ofReal_re]
              positivity
          ¬∑ positivity
        apply mul_le_mul
        ¬∑ exact temp
        ¬∑ exact this
        ¬∑ rw[Complex.norm_cpow_eq_rpow_re_of_pos]
          ¬∑ rw[sub_re, mul_re, ofReal_re, I_re, I_im, reThree, imThree]
            ring_nf
            apply Real.rpow_nonneg
            positivity
          ¬∑ positivity
        ¬∑ exact div_nonneg CNonneg (le_of_lt Œµ_pos)
      exact intervalIntegral.norm_integral_le_of_norm_le_const this
    have : C * X * X ^ (-A / Real.log T) / Œµ * |œÉ‚ÇÅ - œÉ‚ÇÇ| ‚â§
      C * X * X ^ (-A / Real.log T) / Œµ := by
      have : |œÉ‚ÇÅ - œÉ‚ÇÇ| ‚â§ 1 := by
        rw[abs_of_nonneg]
        ¬∑ rw[‚Üê sub_zero 1]
          exact sub_le_sub œÉ‚ÇÅ_lt_one.le hœÉ‚ÇÇ.1.le
        ¬∑ rw[sub_nonneg]
          exact œÉ‚ÇÇ_le_œÉ‚ÇÅ
      bound
    exact le_trans temp this
  simp only [norm_nonneg]
  norm_num


lemma I6Bound {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    --(SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    --(mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1)
    (ContDiffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    {œÉ‚ÇÇ : ‚Ñù} (h_logDeriv_holo : LogDerivZetaIsHoloSmall œÉ‚ÇÇ) (hœÉ‚ÇÇ : œÉ‚ÇÇ ‚àà Ioo 0 1)
    {A : ‚Ñù} --{A CŒ∂ : ‚Ñù} (hCŒ∂ : LogDerivZetaHasBound A CŒ∂) (CŒ∂pos : 0 < CŒ∂)
    (hA : A ‚àà Ioc 0 (1 / 2)) :
    ‚àÉ (C : ‚Ñù) (_ : 0 ‚â§ C) (Tlb : ‚Ñù) (_ : 3 < Tlb),
    ‚àÄ (X : ‚Ñù) (_ : 3 < X)
    {Œµ : ‚Ñù} (_ : 0 < Œµ) (_ : Œµ < 1)
    {T : ‚Ñù} (_ : Tlb < T),
    let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
    ‚ÄñI‚ÇÜ SmoothingF Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ ‚â§ C * X * X ^ (- A / (Real.log T)) / Œµ := by
  obtain ‚ü®C, Cpos, Tlb, Tlb_gt, bound‚ü© := I4Bound suppSmoothingF ContDiffSmoothingF h_logDeriv_holo hœÉ‚ÇÇ hA
  refine ‚ü®C, Cpos, Tlb, Tlb_gt, fun X X_gt Œµ Œµpos Œµ_lt_one T T_gt ‚Ü¶ ?_‚ü©
  specialize bound X X_gt Œµpos Œµ_lt_one T_gt
  intro œÉ‚ÇÅ
  rwa [I6I4 (by linarith), norm_neg, norm_conj]

/-%%
\begin{proof}\uses{MellinOfSmooth1b, LogDerivZetaBndAlt, I4, I6}\leanok
The analysis of $I_4$ is similar to that of $I_2$, (in Lemma \ref{I2Bound}) but even easier.
Let $C$ be the sup of $-\zeta'/\zeta$ on the curve $\sigma_2 + 3 i$ to $1+ 3i$ (this curve is compact, and away from the pole at $s=1$).
Apply Theorem \ref{MellinOfSmooth1b} to get the bound $1/(\epsilon |s|^2)$, which is bounded by $C'/\epsilon$.
And $X^s$ is bounded by $X^{\sigma_1} = X \cdot X^{-A/ \log T^9}$.
Putting these together gives the result.
\end{proof}
%%-/


lemma LogDerivZetaBoundedAndHolo : ‚àÉ A C : ‚Ñù, 0 < C ‚àß A ‚àà Ioc 0 (1 / 2) ‚àß LogDerivZetaHasBound A C
    ‚àß ‚àÄ (T : ‚Ñù) (_ : 3 ‚â§ T),
    HolomorphicOn (fun (s : ‚ÑÇ) ‚Ü¶ Œ∂' s / (Œ∂ s))
    (( (Icc ((1 : ‚Ñù) - A / Real.log T ^ 1) 2)  √ó‚ÑÇ (Icc (-T) T) ) \ {1}) := by
  -- Use the uniform bound with exponent 2 and holomorphicity on the ^1-rectangle,
  -- then adjust constants to match our LogDerivZetaHasBound (which uses log^9 in the RHS).
  obtain ‚ü®A‚ÇÅ, A‚ÇÅ_in, C, C_pos, zeta_bnd2‚ü© := LogDerivZetaBndUnif2
  obtain ‚ü®A‚ÇÇ, A‚ÇÇ_in, holo‚ü© := LogDerivZetaHolcLargeT'
  refine ‚ü®min A‚ÇÅ A‚ÇÇ, C, C_pos, ?_, ?_, ?_‚ü©
  ¬∑ exact ‚ü®lt_min A‚ÇÅ_in.1 A‚ÇÇ_in.1, le_trans (min_le_left _ _) A‚ÇÅ_in.2‚ü©
  ¬∑ -- Bound: use the log^2 bound and the fact log^2 ‚â§ log^9 for |t|>3 (so log|t|>1).
    intro œÉ t ht hœÉ
    have hœÉ' : œÉ ‚àà Ici (1 - A‚ÇÅ / Real.log |t| ^ 1) := by
      -- Since min A‚ÇÅ A‚ÇÇ ‚â§ A‚ÇÅ, the lower threshold 1 - A‚ÇÅ/log ‚â§ 1 - min/log ‚â§ œÉ
      -- Hence œÉ ‚â• 1 - A‚ÇÅ/log.
      have hAle : min A‚ÇÅ A‚ÇÇ ‚â§ A‚ÇÅ := min_le_left _ _
      have hlogpos : 0 < Real.log |t| := by
        -- |t| > 3 ‚áí log|t| > 0
        exact Real.log_pos (lt_trans (by norm_num) ht)
      have := sub_le_sub_left
        (div_le_div_of_nonneg_right (show min A‚ÇÅ A‚ÇÇ ‚â§ A‚ÇÅ from hAle) (le_of_lt hlogpos)) 1
      -- 1 - A‚ÇÅ / log ‚â§ 1 - min / log
      have hthr : 1 - A‚ÇÅ / Real.log |t| ^ 1 ‚â§ 1 - (min A‚ÇÅ A‚ÇÇ) / Real.log |t| ^ 1 := by
        simpa [pow_one] using this
      -- hœÉ : œÉ ‚â• 1 - (min A‚ÇÅ A‚ÇÇ) / log |t|
      have : œÉ ‚àà Ici (1 - (min A‚ÇÅ A‚ÇÇ) / Real.log |t| ^ 1) := by
        simpa [pow_one] using hœÉ
      exact le_trans hthr (mem_Ici.mp this)
    -- Apply the log^2 bound, then compare exponents 2 ‚â§ 9 since log|t| ‚â• 1
    have hmain := zeta_bnd2 œÉ t ht (by simpa [pow_one] using hœÉ')
    have hlog_ge_one : (1 : ‚Ñù) ‚â§ Real.log |t| := by
      -- from |t| > 3 we have log|t| ‚â• 1 since exp 1 ‚â§ 3 < |t|
      have hpos : 0 < |t| := lt_trans (by norm_num) ht
      have hle : Real.exp 1 ‚â§ |t| := by
        have : Real.exp 1 ‚â§ 3 := le_of_lt (lt_trans Real.exp_one_lt_d9 (by norm_num))
        exact this.trans (le_of_lt ht)
      have := Real.log_le_log (Real.exp_pos 1) hle
      simpa [Real.log_exp] using this
    have hpow : Real.log |t| ^ (2 : ‚Ñï) ‚â§ Real.log |t| ^ (9 : ‚Ñï) := by
      exact pow_le_pow_right‚ÇÄ hlog_ge_one (by decide : (2 : ‚Ñï) ‚â§ 9)
    -- Multiply both sides by C ‚â• 0
    have : C * Real.log |t| ^ (2 : ‚Ñï) ‚â§ C * Real.log |t| ^ (9 : ‚Ñï) :=
      mul_le_mul_of_nonneg_left hpow (le_of_lt C_pos)
    exact (le_trans hmain this)
  ¬∑ -- Holomorphic: restrict the ^1-rectangle using A := min A‚ÇÅ A‚ÇÇ ‚â§ A‚ÇÇ
    intro T hT
    -- Our rectangle is a subset since 1 - (min A‚ÇÅ A‚ÇÇ)/log T ‚â• 1 - A‚ÇÇ/log T
    have hsubset :
        ((Icc ((1 : ‚Ñù) - min A‚ÇÅ A‚ÇÇ / Real.log T ^ 1) 2) √ó‚ÑÇ (Icc (-T) T) \ {1}) ‚äÜ
        ((Icc ((1 : ‚Ñù) - A‚ÇÇ / Real.log T ^ 1) 2) √ó‚ÑÇ (Icc (-T) T) \ {1}) := by
      intro s hs
      rcases hs with ‚ü®hs_box, hs_ne‚ü©
      rcases hs_box with ‚ü®hre, him‚ü©
      rcases hre with ‚ü®hre_left, hre_right‚ü©
      -- build the new box membership
      constructor
      ¬∑ -- s ‚àà Icc (1 - A‚ÇÇ / Real.log T ^ 1) 2 √ó‚ÑÇ Icc (-T) T
        constructor
        ¬∑ -- s ‚àà re ‚Åª¬π' Icc (1 - A‚ÇÇ / Real.log T ^ 1) 2
          constructor
          ¬∑ -- 1 - A‚ÇÇ / Real.log T ^ 1 ‚â§ s.re
            have hAle : min A‚ÇÅ A‚ÇÇ ‚â§ A‚ÇÇ := min_le_right _ _
            have hlogpos : 0 < Real.log T := by
              have hT' : 1 < T := by linarith
              exact Real.log_pos hT'
            have := sub_le_sub_left
              (div_le_div_of_nonneg_right hAle (le_of_lt hlogpos)) 1
            have hthr : 1 - A‚ÇÇ / Real.log T ^ 1 ‚â§ 1 - (min A‚ÇÅ A‚ÇÇ) / Real.log T ^ 1 := by
              simpa [pow_one] using this
            exact le_trans hthr hre_left
          ¬∑ exact hre_right
        ¬∑ exact him
      ¬∑ exact hs_ne
    exact (holo T hT).mono hsubset

open Filter Topology

/-%%
\section{Strong_PNT}

\begin{theorem}[Strong_PNT]\label{Strong_PNT}\lean{Strong_PNT}\leanok  We have
$$ \sum_{n \leq x} \Lambda(n) = x + O(x \exp(-c(\log x)^{1/2})).$$
\end{theorem}
%%-/
/-- *** Prime Number Theorem (Strong_ Strength) *** The `ChebyshevPsi` function is asymptotic to `x`. -/
theorem Strong_PNT : ‚àÉ c > 0,
    (œà - id) =O[atTop]
      fun (x : ‚Ñù) ‚Ü¶ x * Real.exp (-c * (Real.log x) ^ ((1 : ‚Ñù) / 2)) := by
  have ‚ü®ŒΩ, ContDiffŒΩ, ŒΩ_nonneg', ŒΩ_supp, ŒΩ_massOne'‚ü© := SmoothExistence
  have ContDiff1ŒΩ : ContDiff ‚Ñù 1 ŒΩ := by
    exact ContDiffŒΩ.of_le (by simp)
  have ŒΩ_nonneg : ‚àÄ x > 0, 0 ‚â§ ŒΩ x := fun x _ ‚Ü¶ ŒΩ_nonneg' x
  have ŒΩ_massOne : ‚à´ x in Ioi 0, ŒΩ x / x = 1 := by
    rwa [‚Üê integral_Ici_eq_integral_Ioi]
  clear ContDiffŒΩ ŒΩ_nonneg'  ŒΩ_massOne'
  obtain ‚ü®c_close, c_close_pos, h_close‚ü© :=
    SmoothedChebyshevClose ContDiff1ŒΩ ŒΩ_supp ŒΩ_nonneg ŒΩ_massOne
  obtain ‚ü®Œµ_main, C_main, Œµ_main_pos, C_main_pos, h_main‚ü©  := MellinOfSmooth1cExplicit ContDiff1ŒΩ ŒΩ_supp ŒΩ_massOne
  obtain ‚ü®A, C_bnd, C_bnd_pos, A_in_Ioc, zeta_bnd, holo1‚ü© := LogDerivZetaBoundedAndHolo
  obtain ‚ü®œÉ‚ÇÇ', œÉ‚ÇÇ'_lt_one, holo2'‚ü© := LogDerivZetaHolcSmallT
  let œÉ‚ÇÇ : ‚Ñù := max œÉ‚ÇÇ' (1 / 2)
  have œÉ‚ÇÇ_pos : 0 < œÉ‚ÇÇ := by bound
  have œÉ‚ÇÇ_lt_one : œÉ‚ÇÇ < 1 := by bound
  have holo2 : HolomorphicOn (fun s ‚Ü¶ Œ∂' s / Œ∂ s) (uIcc œÉ‚ÇÇ 2 √ó‚ÑÇ uIcc (-3) 3 \ {1}) := by
    apply holo2'.mono
    intro s hs
    simp [mem_reProdIm] at hs ‚ä¢
    refine ‚ü®?_, hs.2‚ü©
    refine ‚ü®?_, hs.1.2‚ü©
    rcases hs.1.1 with ‚ü®left, right‚ü©
    constructor
    ¬∑ apply le_trans _ left
      apply min_le_min_right
      apply le_max_left
    ¬∑ rw [max_eq_right (by linarith)] at right ‚ä¢
      exact right

  clear holo2' œÉ‚ÇÇ'_lt_one

  obtain ‚ü®c‚ÇÅ, c‚ÇÅpos, hc‚ÇÅ‚ü© := I1Bound ŒΩ_supp ContDiff1ŒΩ ŒΩ_nonneg ŒΩ_massOne
  obtain ‚ü®c‚ÇÇ, c‚ÇÇpos, hc‚ÇÇ‚ü© := I2Bound ŒΩ_supp ContDiff1ŒΩ zeta_bnd C_bnd_pos A_in_Ioc
  obtain ‚ü®c‚ÇÉ, c‚ÇÉpos, hc‚ÇÉ‚ü© := I3Bound ŒΩ_supp ContDiff1ŒΩ zeta_bnd C_bnd_pos A_in_Ioc
  obtain ‚ü®c‚ÇÖ, c‚ÇÖpos, hc‚ÇÖ‚ü© := I5Bound ŒΩ_supp ContDiff1ŒΩ holo2  ‚ü®œÉ‚ÇÇ_pos, œÉ‚ÇÇ_lt_one‚ü©
  obtain ‚ü®c‚Çá, c‚Çápos, hc‚Çá‚ü© := I7Bound ŒΩ_supp ContDiff1ŒΩ zeta_bnd C_bnd_pos A_in_Ioc
  obtain ‚ü®c‚Çà, c‚Çàpos, hc‚Çà‚ü© := I8Bound ŒΩ_supp ContDiff1ŒΩ zeta_bnd C_bnd_pos A_in_Ioc
  obtain ‚ü®c‚Çâ, c‚Çâpos, hc‚Çâ‚ü© := I9Bound ŒΩ_supp ContDiff1ŒΩ ŒΩ_nonneg ŒΩ_massOne

  obtain ‚ü®c‚ÇÑ, c‚ÇÑpos, Tlb‚ÇÑ, Tlb‚ÇÑbnd, hc‚ÇÑ‚ü© := I4Bound ŒΩ_supp ContDiff1ŒΩ
    holo2 ‚ü®œÉ‚ÇÇ_pos, œÉ‚ÇÇ_lt_one‚ü© A_in_Ioc

  obtain ‚ü®c‚ÇÜ, c‚ÇÜpos, Tlb‚ÇÜ, Tlb‚ÇÜbnd, hc‚ÇÜ‚ü© := I6Bound ŒΩ_supp ContDiff1ŒΩ
    holo2 ‚ü®œÉ‚ÇÇ_pos, œÉ‚ÇÇ_lt_one‚ü© A_in_Ioc

  let C' := c_close + C_main
  let C'' := c‚ÇÅ + c‚ÇÇ + c‚Çà + c‚Çâ
  let C''' := c‚ÇÉ + c‚ÇÑ + c‚ÇÜ + c‚Çá


  let c : ‚Ñù := A ^ ((1 : ‚Ñù) / 2) / 4
  have cpos : 0 < c := by
    simp_all only [one_div, support_subset_iff, ne_eq, mem_Icc, gt_iff_lt, mem_Ioo, and_imp,
      mem_Ioc, lt_sup_iff,
      inv_pos, Nat.ofNat_pos, or_true, sup_lt_iff, neg_le_self_iff, Nat.ofNat_nonneg, uIcc_of_le,
      div_pos_iff_of_pos_right, œÉ‚ÇÇ, c]
    obtain ‚ü®left, right‚ü© := A_in_Ioc
    positivity
  refine ‚ü®c, cpos, ?_‚ü©
  rw [Asymptotics.isBigO_iff]
  let C : ‚Ñù := C' + C'' + C''' + c‚ÇÖ
  refine ‚ü®C, ?_‚ü©

  let c_Œµx : ‚Ñù := A ^ ((1 : ‚Ñù) / 2) / 2
  have c_Œµx_pos : 0 < c_Œµx := by
    simp_all only [one_div, support_subset_iff, ne_eq, mem_Icc, gt_iff_lt, mem_Ioo, and_imp,
      mem_Ioc, lt_sup_iff,
      inv_pos, Nat.ofNat_pos, or_true, sup_lt_iff, neg_le_self_iff, Nat.ofNat_nonneg, uIcc_of_le,
      div_pos_iff_of_pos_right, div_pos_iff_of_pos_left, œÉ‚ÇÇ, c, c_Œµx]
  let c_Tx : ‚Ñù := A ^ ((1 : ‚Ñù) / 2)
  have c_Tx_pos : 0 < c_Tx := by
    simp_all only [one_div, support_subset_iff, ne_eq, mem_Icc, gt_iff_lt, mem_Ioo, and_imp,
      mem_Ioc, lt_sup_iff,
      inv_pos, Nat.ofNat_pos, or_true, sup_lt_iff, neg_le_self_iff, Nat.ofNat_nonneg, uIcc_of_le,
      div_pos_iff_of_pos_right, œÉ‚ÇÇ, c, c_Œµx, c_Tx]


  let Œµx := (fun x ‚Ü¶ Real.exp (-c_Œµx * (Real.log x) ^ ((1 : ‚Ñù) / 2)))
  let Tx := (fun x ‚Ü¶ Real.exp (c_Tx * (Real.log x) ^ ((1 : ‚Ñù) / 2)))

  have Tx_to_inf : Tendsto Tx atTop atTop := by
    unfold Tx
    apply tendsto_exp_atTop.comp
    apply Tendsto.pos_mul_atTop c_Tx_pos tendsto_const_nhds
    exact (tendsto_rpow_atTop (by norm_num : 0 < (1 : ‚Ñù) / 2)).comp Real.tendsto_log_atTop

  have ex_to_zero : Tendsto Œµx atTop (ùìù 0) := by
    unfold Œµx
    apply Real.tendsto_exp_atBot.comp
    have this (x) : -c_Œµx * Real.log x ^ ((1 : ‚Ñù) / 2) = -(c_Œµx * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
      ring
    simp_rw [this]
    rw [tendsto_neg_atBot_iff]
    apply Tendsto.const_mul_atTop c_Œµx_pos
    apply (tendsto_rpow_atTop (by norm_num)).comp
    exact tendsto_log_atTop

  have eventually_Œµx_lt_one : ‚àÄ·∂† (x : ‚Ñù) in atTop, Œµx x < 1 := by
    apply (tendsto_order.mp ex_to_zero).2
    norm_num

  have eventually_2_lt : ‚àÄ·∂† (x : ‚Ñù) in atTop, 2 < x * Œµx x := by
    have := x_Œµ_to_inf c_Œµx (by norm_num : (1 : ‚Ñù) / 2 < 1)
    exact this.eventually_gt_atTop 2

  have eventually_T_gt_3 : ‚àÄ·∂† (x : ‚Ñù) in atTop, 3 < Tx x := by
    exact Tx_to_inf.eventually_gt_atTop 3

  have eventually_T_gt_Tlb‚ÇÑ : ‚àÄ·∂† (x : ‚Ñù) in atTop, Tlb‚ÇÑ < Tx x := by
    exact Tx_to_inf.eventually_gt_atTop _
  have eventually_T_gt_Tlb‚ÇÜ : ‚àÄ·∂† (x : ‚Ñù) in atTop, Tlb‚ÇÜ < Tx x := by
    exact Tx_to_inf.eventually_gt_atTop _

  have eventually_œÉ‚ÇÇ_lt_œÉ‚ÇÅ : ‚àÄ·∂† (x : ‚Ñù) in atTop, œÉ‚ÇÇ < 1 - A / (Real.log (Tx x)) := by
    --have' := (tendsto_order.mp ?_).1
    apply (tendsto_order.mp ?_).1
    ¬∑ exact œÉ‚ÇÇ_lt_one
    have := tendsto_inv_atTop_zero.comp ((tendsto_rpow_atTop (by norm_num : (0 : ‚Ñù) < 1)).comp
      (tendsto_log_atTop.comp Tx_to_inf))
    have := Tendsto.const_mul (b := A) this
    convert (tendsto_const_nhds (x := (1 : ‚Ñù))).sub this using 2
    ¬∑ simp [Function.comp, pow_one, div_eq_mul_inv]
    ¬∑ simp

  have eventually_Œµ_lt_Œµ_main : ‚àÄ·∂† (x : ‚Ñù) in atTop, Œµx x < Œµ_main := by
    apply (tendsto_order.mp ex_to_zero).2
    assumption

  have event_logX_ge : ‚àÄ·∂† (x : ‚Ñù) in atTop, 1 ‚â§ Real.log x := by
    apply Real.tendsto_log_atTop.eventually_ge_atTop

  have event_1_aux_1 {const1 const2 : ‚Ñù} (const1pos : 0 < const1) (const2pos : 0 < const2) :
    ‚àÄ·∂† (x : ‚Ñù) in atTop,
    rexp (-const1 * Real.log x ^ const2) * Real.log x ‚â§
    rexp 0 := by
      have := ((isLittleO_log_rpow_atTop const2pos).bound const1pos)
      have : ‚àÄ·∂† (x : ‚Ñù) in atTop, Real.log (Real.log x) ‚â§
          const1 * (Real.log x) ^ const2 := by
        have := tendsto_log_atTop.eventually this
        filter_upwards [this, eventually_gt_atTop 100] with x hx x_gt
        convert hx using 1
        ¬∑ rw [Real.norm_of_nonneg]
          apply Real.log_nonneg
          have : (1 : ‚Ñù) = Real.log (rexp 1) := by
            exact Eq.symm (Real.log_exp 1)

          rw [this]
          apply Real.log_le_log
          ¬∑ exact Real.exp_pos _
          ¬∑ have := Real.exp_one_lt_d9
            -- linarith
            linarith
        ¬∑ congr! 1
          rw [Real.norm_of_nonneg]
          apply Real.rpow_nonneg
          apply Real.log_nonneg
          linarith
      have loglogx :  ‚àÄ·∂† (x : ‚Ñù) in atTop,
          Real.log x = rexp (Real.log (Real.log x)) := by
        filter_upwards [eventually_gt_atTop 3] with x hx
        rw [Real.exp_log]
        apply Real.log_pos
        linarith
      filter_upwards [loglogx, this] with x loglogx hx
      conv =>
        enter [1, 2]
        rw [loglogx]
      rw [‚Üê Real.exp_add]
      apply Real.exp_monotone
      grw [hx]
      simp

  have event_1_aux {const1 const1' const2 : ‚Ñù} (const1bnds : const1' < const1)
    (const2pos : 0 < const2) :
    ‚àÄ·∂† (x : ‚Ñù) in atTop,
    rexp (-const1 * Real.log x ^ const2) * Real.log x ‚â§
    rexp (-const1' * Real.log x ^ const2) := by
      have : 0 < const1 - const1' := by linarith
      filter_upwards [event_1_aux_1 this const2pos] with x hx
      have : rexp (-const1 * Real.log x ^ const2) * Real.log x
        = rexp (-(const1') * Real.log x ^ const2)
          * rexp (-(const1 - const1') * Real.log x ^ const2) * Real.log x := by
          congr! 1
          rw [‚Üê Real.exp_add]
          congr! 1
          ring
      rw [this]
      rw [mul_assoc]
      grw [hx]
      simp

  have event_1 : ‚àÄ·∂† (x : ‚Ñù) in atTop, C' * (Œµx x) * x * Real.log x ‚â§
      C' * x * rexp (-c * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
    unfold c Œµx c_Œµx
    have : 0 < (A ^ ((1 : ‚Ñù) / 2) / 4) := by
        positivity
    have const1bnd : (A ^ ((1 : ‚Ñù) / 2) / 4) < (A ^ ((1 : ‚Ñù) / 2) / 2) := by
        linarith
    have const2bnd : (0 : ‚Ñù) < 1 / 2 := by norm_num
    have this (x) :
      C' * rexp (-(A ^ ((1 : ‚Ñù) / 2) / 2) * Real.log x ^ ((1 : ‚Ñù) / 2)) * x * Real.log x =
      C' * x * (rexp (-(A ^ ((1 : ‚Ñù) / 2) / 2) * Real.log x ^ ((1 : ‚Ñù) / 2)) * Real.log x) := by ring
    simp_rw [this]
    filter_upwards [event_1_aux const1bnd const2bnd, eventually_gt_atTop 3] with x x_bnd x_gt
    grw [x_bnd]

  have event_2 : ‚àÄ·∂† (x : ‚Ñù) in atTop, C'' * x * Real.log x / (Œµx x * Tx x) ‚â§
      C'' * x * rexp (-c * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
    unfold c Œµx c_Œµx Tx c_Tx
    set const2 : ‚Ñù := 1 / 2
    have const2bnd : 0 < const2 := by norm_num
    set const1 := (A ^ const2 / 2)
    set const1' := (A ^ const2 / 4)
    have : 0 < A ^ const2 := by
      unfold const2
      --positivity -- fails?? Worked before
      apply Real.rpow_pos_of_pos
      exact A_in_Ioc.1
    have this (x) : -(-const1 * Real.log x ^ const2 + A ^ const2 * Real.log x ^ const2) =
      -(A ^ const2 - const1) * Real.log x ^ const2 := by ring
    simp_rw [‚Üê Real.exp_add, div_eq_mul_inv, ‚Üê Real.exp_neg, this]
    have const1bnd : const1' < (A ^ const2 - const1) := by
      unfold const1' const1
      linarith
    filter_upwards [event_1_aux const1bnd const2bnd, eventually_gt_atTop 3] with x x_bnd x_gt
    rw [mul_assoc]
    conv =>
      enter [1, 2]
      rw [mul_comm]
    grw [x_bnd]

  have event_3_aux {const1 const1' const2 : ‚Ñù} (const2_eq : const2 = 1 / 2)
    (const1_eq : const1 = (A ^ const2 / 2)) (const1'_eq : const1' = (A ^ const2 / 4)) :
    ‚àÄ·∂† (x : ‚Ñù) in atTop,
      x ^ (-A / Real.log (rexp (A ^ const2 * Real.log x ^ const2)) ^ (1 : ‚Ñù)) *
      rexp (-(-const1 * Real.log x ^ const2)) ‚â§
      rexp (-const1' * Real.log x ^ const2) := by
    have : ‚àÄ·∂† (x : ‚Ñù) in atTop, x = rexp (Real.log x) := by
      filter_upwards [eventually_gt_atTop 0] with x hx
      rw [Real.exp_log hx]
    filter_upwards [this, eventually_gt_atTop 3] with x hx x_gt_3
    have logxpos : 0 < Real.log x := by apply Real.log_pos; linarith
    conv =>
      enter [1, 1, 1]
      rw [hx]
    rw [‚Üê Real.exp_mul]
    rw [Real.log_exp]
    rw [Real.mul_rpow]
    ¬∑ have {y : ‚Ñù} (ypos : 0 < y) : y / (y ^ const2) ^ (1 : ‚Ñù) = y ^ const2 := by
        rw [‚Üê Real.rpow_mul ypos.le]
        rw [div_eq_mul_inv]
        rw [‚Üê Real.rpow_neg ypos.le]
        conv =>
          enter [1, 1]
          rw [‚Üê Real.rpow_one y]
        rw [‚Üê Real.rpow_add ypos]
        rw [(by linarith : 1 + -(const2 * 1) = const2)]
      rw [div_mul_eq_div_div]
      rw [neg_div]
      rw [this (A_in_Ioc.1)]

      rw [mul_div]
      conv =>
        enter [1, 1, 1, 1]
        rw [mul_comm]
      rw [‚Üê mul_div]

      rw [this (y := Real.log x) logxpos]

      rw [‚Üê Real.exp_add]
      apply Real.exp_monotone

      have : -A ^ const2 * Real.log x ^ const2 + -(-const1 * Real.log x ^ const2)
       = (-(A ^ const2 - const1) * Real.log x ^ const2) := by ring
      rw [this]

      gcongr

      rw [const1'_eq, const1_eq]
      have : 0 ‚â§ A ^ const2 := by
        apply Real.rpow_nonneg A_in_Ioc.1.le
      linarith
    ¬∑ rw [const2_eq]
      rw [‚ÜêReal.sqrt_eq_rpow]
      apply Real.sqrt_nonneg

    ¬∑ apply Real.rpow_nonneg
      apply Real.log_nonneg
      linarith

  have event_3 : ‚àÄ·∂† (x : ‚Ñù) in atTop, C''' * x * x ^ (-A / Real.log (Tx x) ) / (Œµx x) ‚â§
      C''' * x * rexp (-c * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
    unfold c Tx c_Tx Œµx c_Œµx
    set const2 : ‚Ñù := 1 / 2
    have const2eq : const2 = 1 / 2 := by rfl
    have const2bnd : 0 < const2 := by norm_num
    set const1 := (A ^ const2 / 2)
    have const1eq : const1 = (A ^ const2 / 2) := by rfl
    set const1' := (A ^ const2 / 4)
    have const1'eq : const1' = (A ^ const2 / 4) := by rfl
    have A_pow_pos : 0 < A ^ const2 := by
      unfold const2
      apply Real.rpow_pos_of_pos
      exact A_in_Ioc.1

    conv =>
      enter [1, x, 1]
      rw [div_eq_mul_inv, ‚Üê Real.exp_neg]

    filter_upwards [event_3_aux const2eq const1eq const1'eq,
      eventually_gt_atTop 3] with x x_bnd x_gt

    have this (x) : C''' * x * x ^ (-A / Real.log (rexp (A ^ const2 * Real.log x ^ const2)))
        * rexp (-(-const1 * Real.log x ^ const2))
      = C''' * x * (x ^ (-A / Real.log (rexp (A ^ const2 * Real.log x ^ const2)))
        * rexp (-(-const1 * Real.log x ^ const2))) := by
      ring
    rw [this]
    rw [rpow_one] at x_bnd
    grw [x_bnd]

  have event_4_aux4 {pow2 : ‚Ñù} (pow2_neg : pow2 < 0) {c : ‚Ñù} (cpos : 0 < c) (c' : ‚Ñù) :
      Tendsto (fun x ‚Ü¶ c' * Real.log x ^ pow2) atTop (ùìù 0) := by
    rw [‚Üê mul_zero c']
    apply Tendsto.const_mul
    have := tendsto_rpow_neg_atTop (y := -pow2) (by linarith)
    rw [neg_neg] at this
    apply this.comp
    exact Real.tendsto_log_atTop

  have event_4_aux3 {pow2 : ‚Ñù} (pow2_neg : pow2 < 0) {c : ‚Ñù} (cpos : 0 < c) (c' : ‚Ñù) :
      ‚àÄ·∂† (x : ‚Ñù) in atTop, c' * (Real.log x) ^ pow2 < c := by
    apply (event_4_aux4 pow2_neg cpos c').eventually_lt_const
    exact cpos

  have event_4_aux2 {c1 : ‚Ñù} (c1pos : 0 < c1) (c2 : ‚Ñù) {pow1 : ‚Ñù} (pow1_lt : pow1 < 1) :
      ‚àÄ·∂† (x : ‚Ñù) in atTop, 0 ‚â§ Real.log x * (c1 - c2 * (Real.log x) ^ (pow1 - 1)) := by
    filter_upwards [eventually_gt_atTop 3 , event_4_aux3 (by linarith : pow1 - 1 < 0)
      (by linarith : 0 < c1 / 2) c2] with x x_gt hx
    have : 0 ‚â§ Real.log x := by
      apply Real.log_nonneg
      linarith
    apply mul_nonneg this
    linarith

  have event_4_aux1 {const1 : ‚Ñù} (const1_lt : const1 < 1) (const2 const3 : ‚Ñù)
      {pow1 : ‚Ñù} (pow1_lt : pow1 < 1) : ‚àÄ·∂† (x : ‚Ñù) in atTop,
      const1 * Real.log x + const2 * Real.log x ^ pow1
        ‚â§ Real.log x - const3 * Real.log x ^ pow1 := by
    filter_upwards [event_4_aux2 (by linarith : 0 < 1 - const1) (const2 + const3) pow1_lt,
      eventually_gt_atTop 3] with x hx x_gt
    rw [‚Üê sub_nonneg]
    have :
      Real.log x - const3 * Real.log x ^ pow1 - (const1 * Real.log x + const2 * Real.log x ^ pow1)
      = (1 - const1) * Real.log x - (const2 + const3) * Real.log x ^ pow1 := by ring
    rw [this]
    convert hx using 1
    ring_nf
    congr! 1
    have : Real.log x * const2 * Real.log x ^ (-1 + pow1)
        = const2 * Real.log x ^ pow1 := by
      rw [mul_assoc, mul_comm, mul_assoc]
      congr! 1
      conv =>
        enter [1, 2]
        rw [‚Üê Real.rpow_one (Real.log x)]
      rw [‚Üê Real.rpow_add (Real.log_pos (by linarith))]
      ring_nf
    rw [this]
    have : Real.log x * const3 * Real.log x ^ (-1 + pow1)
        = const3 * Real.log x ^ pow1 := by
      rw [mul_assoc, mul_comm, mul_assoc]
      congr! 1
      conv =>
        enter [1, 2]
        rw [‚Üê Real.rpow_one (Real.log x)]
      rw [‚Üê Real.rpow_add (Real.log_pos (by linarith))]
      ring_nf
    rw [this]



  have event_4_aux : ‚àÄ·∂† (x : ‚Ñù) in atTop,
      c‚ÇÖ * rexp (œÉ‚ÇÇ * Real.log x + (A ^ ((1 : ‚Ñù) / 2) / 2) * Real.log x ^ ((1 : ‚Ñù) / 2)) ‚â§
      c‚ÇÖ * rexp (Real.log x - (A ^ ((1 : ‚Ñù) / 2) / 4) * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
    filter_upwards [eventually_gt_atTop 3, event_4_aux1 œÉ‚ÇÇ_lt_one (A ^ ((1 : ‚Ñù) / 2) / 2)
      (A ^ ((1 : ‚Ñù) / 2) / 4) (by norm_num : (1 : ‚Ñù) / 2 < 1)] with x x_gt hx
    rw [mul_le_mul_left c‚ÇÖpos]
    apply Real.exp_monotone
    convert hx

  have event_4 : ‚àÄ·∂† (x : ‚Ñù) in atTop, c‚ÇÖ * x ^ œÉ‚ÇÇ / (Œµx x) ‚â§
      c‚ÇÖ * x * rexp (-c * Real.log x ^ ((1 : ‚Ñù) / 2)) := by
    unfold Œµx c_Œµx c
    filter_upwards [event_4_aux, eventually_gt_atTop 0] with x hx xpos
    convert hx using 1
    ¬∑ rw [‚Üê mul_div]
      congr! 1
      rw [div_eq_mul_inv, ‚Üê Real.exp_neg]
      conv =>
        enter [1, 1, 1]
        rw [‚Üê Real.exp_log xpos]
      rw [‚Üê exp_mul, ‚Üê Real.exp_add]
      ring_nf

    ¬∑ rw [mul_assoc]
      congr! 1
      conv =>
        enter [1, 1]
        rw [‚Üê Real.exp_log xpos]
      rw [‚Üê Real.exp_add]
      ring_nf


  filter_upwards [eventually_gt_atTop 3, eventually_Œµx_lt_one, eventually_2_lt,
    eventually_T_gt_3, eventually_T_gt_Tlb‚ÇÑ, eventually_T_gt_Tlb‚ÇÜ,
      eventually_œÉ‚ÇÇ_lt_œÉ‚ÇÅ, eventually_Œµ_lt_Œµ_main, event_logX_ge, event_1, event_2,
      event_3, event_4] with X X_gt_3 Œµ_lt_one Œµ_X T_gt_3 T_gt_Tlb‚ÇÑ T_gt_Tlb‚ÇÜ
      œÉ‚ÇÇ_lt_œÉ‚ÇÅ Œµ_lt_Œµ_main logX_ge event_1 event_2 event_3 event_4

  clear eventually_Œµx_lt_one eventually_2_lt eventually_T_gt_3 eventually_T_gt_Tlb‚ÇÑ
    eventually_T_gt_Tlb‚ÇÜ eventually_œÉ‚ÇÇ_lt_œÉ‚ÇÅ eventually_Œµ_lt_Œµ_main event_logX_ge zeta_bnd
    -- ŒΩ_nonneg ŒΩ_massOne ContDiff1ŒΩ ŒΩ_supp

  let Œµ : ‚Ñù := Œµx X
  have Œµ_pos : 0 < Œµ := by positivity
  specialize h_close X X_gt_3 Œµ Œµ_pos Œµ_lt_one Œµ_X
  let œà_Œµ_of_X := SmoothedChebyshev ŒΩ Œµ X

  let T : ‚Ñù := Tx X
  specialize holo1 T T_gt_3.le
  let œÉ‚ÇÅ : ‚Ñù := 1 - A / (Real.log T)
  have œÉ‚ÇÅpos : 0 < œÉ‚ÇÅ := by calc
    1 - A / (Real.log T) >= 1 - (1/2) / 1 := by
      gcongr
      ¬∑ exact A_in_Ioc.2
      ¬∑ apply (Real.le_log_iff_exp_le (by positivity)).mpr
        linarith[Real.exp_one_lt_d9]
    _ > 0 := by norm_num
  have œÉ‚ÇÅ_lt_one : œÉ‚ÇÅ < 1 := by
    apply sub_lt_self
    apply div_pos A_in_Ioc.1
    bound

  rw [uIcc_of_le (by linarith), uIcc_of_le (by linarith)] at holo2

  have holo1_compat : HolomorphicOn (Œ∂' / Œ∂) (Icc œÉ‚ÇÅ 2 √ó‚ÑÇ Icc (-T) T \ {1}) := by
    -- direct from holo1 with ^1-rectangle
    simpa [œÉ‚ÇÅ, pow_one] using holo1

  have holo2a : HolomorphicOn (SmoothedChebyshevIntegrand ŒΩ Œµ X)
      (Icc œÉ‚ÇÇ 2 √ó‚ÑÇ Icc (-3) 3 \ {1}) := by
    apply DifferentiableOn.mul
    ¬∑ apply DifferentiableOn.mul
      ¬∑ rw [(by ext; ring : (fun s ‚Ü¶ -Œ∂' s / Œ∂ s) = (fun s ‚Ü¶ -(Œ∂' s / Œ∂ s)))]
        apply DifferentiableOn.neg holo2
      ¬∑ intro s hs
        apply DifferentiableAt.differentiableWithinAt
        apply Smooth1MellinDifferentiable ContDiff1ŒΩ ŒΩ_supp ‚ü®Œµ_pos, Œµ_lt_one‚ü© ŒΩ_nonneg ŒΩ_massOne
        linarith[mem_reProdIm.mp hs.1 |>.1.1]
    ¬∑ intro s hs
      apply DifferentiableAt.differentiableWithinAt
      apply DifferentiableAt.const_cpow (by fun_prop)
      left
      norm_cast
      linarith
  have œà_Œµ_diff : ‚Äñœà_Œµ_of_X - ùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X‚Äñ ‚â§ ‚ÄñI‚ÇÅ ŒΩ Œµ X T‚Äñ + ‚ÄñI‚ÇÇ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ
    + ‚ÄñI‚ÇÉ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÑ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ + ‚ÄñI‚ÇÖ ŒΩ Œµ X œÉ‚ÇÇ‚Äñ + ‚ÄñI‚ÇÜ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ + ‚ÄñI‚Çá ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ
    + ‚ÄñI‚Çà ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚Çâ ŒΩ Œµ X T‚Äñ := by
    unfold œà_Œµ_of_X
    rw [SmoothedChebyshevPull1 Œµ_pos Œµ_lt_one X X_gt_3 (T := T) (by linarith)
      œÉ‚ÇÅpos œÉ‚ÇÅ_lt_one holo1_compat ŒΩ_supp ŒΩ_nonneg ŒΩ_massOne ContDiff1ŒΩ]
    rw [SmoothedChebyshevPull2 Œµ_pos Œµ_lt_one X X_gt_3 (T := T) (by linarith)
      œÉ‚ÇÇ_pos œÉ‚ÇÅ_lt_one œÉ‚ÇÇ_lt_œÉ‚ÇÅ holo1_compat holo2a ŒΩ_supp ŒΩ_nonneg ŒΩ_massOne ContDiff1ŒΩ]
    ring_nf
    iterate 5
      apply le_trans (by apply norm_add_le)
      gcongr
    apply le_trans (by apply norm_add_le)
    rw [(by ring : ‚ÄñI‚ÇÅ ŒΩ Œµ X T‚Äñ + ‚ÄñI‚ÇÇ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÉ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÑ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ =
      (‚ÄñI‚ÇÅ ŒΩ Œµ X T‚Äñ + ‚ÄñI‚ÇÇ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ) + (‚ÄñI‚ÇÉ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÑ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ))]
    gcongr <;> apply le_trans (by apply norm_sub_le) <;> rfl
  specialize h_main Œµ ‚ü®Œµ_pos, Œµ_lt_Œµ_main‚ü©
  have main : ‚Äñùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X - X‚Äñ ‚â§ C_main * Œµ * X := by
    nth_rewrite 2 [‚Üê one_mul X]
    push_cast
    rw [‚Üê sub_mul, norm_mul]
    gcongr
    rw [norm_real, norm_of_nonneg (by linarith)]
  specialize hc‚ÇÅ Œµ Œµ_pos Œµ_lt_one X X_gt_3 T_gt_3
  specialize hc‚ÇÇ X X_gt_3 Œµ_pos Œµ_lt_one T_gt_3
  specialize hc‚ÇÉ X X_gt_3 Œµ_pos Œµ_lt_one T_gt_3
  specialize hc‚ÇÖ X X_gt_3 Œµ_pos Œµ_lt_one
  specialize hc‚Çá X X_gt_3 Œµ_pos Œµ_lt_one T_gt_3
  specialize hc‚Çà X X_gt_3 Œµ_pos Œµ_lt_one T_gt_3
  specialize hc‚Çâ Œµ_pos Œµ_lt_one X X_gt_3 T_gt_3
  specialize hc‚ÇÑ X X_gt_3 Œµ_pos Œµ_lt_one T_gt_Tlb‚ÇÑ
  specialize hc‚ÇÜ X X_gt_3 Œµ_pos Œµ_lt_one T_gt_Tlb‚ÇÜ

  clear ŒΩ_nonneg ŒΩ_massOne ContDiff1ŒΩ ŒΩ_supp holo2

  have C'bnd : c_close * Œµ * X * Real.log X + C_main * Œµ * X ‚â§ C' * Œµ * X * Real.log X := by
    have : C_main * Œµ * X * 1 ‚â§ C_main * Œµ * X * Real.log X := by
      gcongr
    linarith

  have C''bnd : c‚ÇÅ * X * Real.log X / (Œµ * T) + c‚ÇÇ * X / (Œµ * T) + c‚Çà * X / (Œµ * T)
    + c‚Çâ * X * Real.log X / (Œµ * T) ‚â§ C'' * X * Real.log X / (Œµ * T) := by
    unfold C''
    rw [(by ring : (c‚ÇÅ + c‚ÇÇ + c‚Çà + c‚Çâ) * X * Real.log X / (Œµ * T)
      = c‚ÇÅ * X * Real.log X / (Œµ * T) + c‚ÇÇ * X * Real.log X / (Œµ * T)
        + c‚Çà * X * Real.log X / (Œµ * T) + c‚Çâ * X * Real.log X / (Œµ * T))]
    have : c‚ÇÇ * X / (Œµ * T) * 1 ‚â§ c‚ÇÇ * X / (Œµ * T) * Real.log X := by
      gcongr
    have : c‚ÇÇ * X / (Œµ * T) ‚â§ c‚ÇÇ * X * Real.log X / (Œµ * T) := by
      ring_nf at this ‚ä¢
      linarith
    grw [this]
    have : c‚Çà * X / (Œµ * T) * 1 ‚â§ c‚Çà * X / (Œµ * T) * Real.log X := by
      gcongr
    have : c‚Çà * X / (Œµ * T) ‚â§ c‚Çà * X * Real.log X / (Œµ * T) := by
      ring_nf at this ‚ä¢
      linarith
    grw [this]

  have C'''bnd : c‚ÇÉ * X * X ^ (-A / Real.log T) / Œµ
                    + c‚ÇÑ * X * X ^ (-A / Real.log T) / Œµ
                    + c‚ÇÜ * X * X ^ (-A / Real.log T) / Œµ
                    + c‚Çá * X * X ^ (-A / Real.log T) / Œµ
                  ‚â§ C''' * X * X ^ (-A / Real.log T) / Œµ := by
    apply le_of_eq
    ring

  calc
    _         = ‚Äñ(œà X - œà_Œµ_of_X) + (œà_Œµ_of_X - X)‚Äñ := by ring_nf; norm_cast
    _         ‚â§ ‚Äñœà X - œà_Œµ_of_X‚Äñ + ‚Äñœà_Œµ_of_X - X‚Äñ := norm_add_le _ _
    _         = ‚Äñœà X - œà_Œµ_of_X‚Äñ + ‚Äñ(œà_Œµ_of_X - ùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X)
                  + (ùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X - X)‚Äñ := by ring_nf
    _         ‚â§ ‚Äñœà X - œà_Œµ_of_X‚Äñ + ‚Äñœà_Œµ_of_X - ùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X‚Äñ
                  + ‚Äñùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X - X‚Äñ := by
                    rw [add_assoc]
                    gcongr
                    apply norm_add_le
    _         = ‚Äñœà X - œà_Œµ_of_X‚Äñ + ‚Äñùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X - X‚Äñ
                  + ‚Äñœà_Œµ_of_X - ùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X‚Äñ := by ring
    _         ‚â§ ‚Äñœà X - œà_Œµ_of_X‚Äñ + ‚Äñùìú (fun x ‚Ü¶ (Smooth1 ŒΩ Œµ x : ‚ÑÇ)) 1 * X - X‚Äñ
                  + (‚ÄñI‚ÇÅ ŒΩ Œµ X T‚Äñ + ‚ÄñI‚ÇÇ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÉ ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚ÇÑ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ
                  + ‚ÄñI‚ÇÖ ŒΩ Œµ X œÉ‚ÇÇ‚Äñ + ‚ÄñI‚ÇÜ ŒΩ Œµ X œÉ‚ÇÅ œÉ‚ÇÇ‚Äñ + ‚ÄñI‚Çá ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ + ‚ÄñI‚Çà ŒΩ Œµ T X œÉ‚ÇÅ‚Äñ
                  + ‚ÄñI‚Çâ ŒΩ Œµ X T‚Äñ) := by gcongr
    _         ‚â§ c_close * Œµ * X * Real.log X + C_main * Œµ * X
                  + (c‚ÇÅ * X * Real.log X / (Œµ * T) + c‚ÇÇ * X / (Œµ * T)
                  + c‚ÇÉ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÑ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÖ * X ^ œÉ‚ÇÇ / Œµ
                  + c‚ÇÜ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚Çá * X * X ^ (-A / Real.log T) / Œµ
                  + c‚Çà * X / (Œµ * T)
                  + c‚Çâ * X * Real.log X / (Œµ * T)) := by
      gcongr
      convert h_close using 1
      rw [‚Üê norm_neg]
      congr
      ring

      -- unfold œÉ‚ÇÅ
      change ‚ÄñI‚ÇÇ ŒΩ Œµ (Tx X) X œÉ‚ÇÅ‚Äñ ‚â§ c‚ÇÇ * X / (Œµ * (Tx X))
      dsimp at hc‚ÇÇ
      dsimp [œÉ‚ÇÅ]
      -- have : sigma1Of = 1 - A / Real.log T := rfl
      unfold sigma1Of at hc‚ÇÇ


      -- dsimp [Tx] at hc‚ÇÇ

      exact hc‚ÇÇ


    _         =  (c_close * Œµ * X * Real.log X + C_main * Œµ * X)
                  + ((c‚ÇÅ * X * Real.log X / (Œµ * T) + c‚ÇÇ * X / (Œµ * T)
                  + c‚Çà * X / (Œµ * T)
                  + c‚Çâ * X * Real.log X / (Œµ * T))
                  + (c‚ÇÉ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÑ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÜ * X * X ^ (-A / Real.log T) / Œµ
                  + c‚Çá * X * X ^ (-A / Real.log T) / Œµ)
                  + c‚ÇÖ * X ^ œÉ‚ÇÇ / Œµ
                  ) := by ring
    _         ‚â§ C' * Œµ * X * Real.log X
                  + (C'' * X * Real.log X / (Œµ * T)
                  + C''' * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÖ * X ^ œÉ‚ÇÇ / Œµ
                  ) := by
      gcongr
    _        = C' * Œµ * X * Real.log X
                  + C'' * X * Real.log X / (Œµ * T)
                  + C''' * X * X ^ (-A / Real.log T) / Œµ
                  + c‚ÇÖ * X ^ œÉ‚ÇÇ / Œµ
                    := by ring
    _        ‚â§ C' * X * rexp (-c * Real.log X ^ ((1 : ‚Ñù) / 2))
                  + C'' * X * rexp (-c * Real.log X ^ ((1 : ‚Ñù) / 2))
                  + C''' * X * rexp (-c * Real.log X ^ ((1 : ‚Ñù) / 2))
                  + c‚ÇÖ * X * rexp (-c * Real.log X ^ ((1 : ‚Ñù) / 2))
                    := by
      gcongr
    _        = C * X * rexp (-c * Real.log X ^ ((1 : ‚Ñù) / 2))
                    := by ring
    _        = _ := by
      rw [Real.norm_of_nonneg]
      ¬∑ rw [‚Üê mul_assoc]
      ¬∑ positivity

/-%%
\begin{proof}
\uses{ChebyshevPsi, SmoothedChebyshevClose, LogDerivZetaBndAlt, ZetaBoxEval, LogDerivZetaBndUniform, LogDerivZetaHolcSmallT, LogDerivZetaHolcLargeT,
SmoothedChebyshevPull1, SmoothedChebyshevPull2, I1Bound, I2Bound, I3Bound, I4Bound, I5Bound}\leanok
  Evaluate the integrals.
\end{proof}
%%-/

#print axioms Strong_PNT
